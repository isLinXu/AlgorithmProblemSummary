# JZ52两个链表的第一个公共结点

---

## 描述

输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

数据范围： n \le 1000*n*≤1000
要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6)

可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。

### 输入描述：

输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。

### 返回值描述：

返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。

## 示例1

输入：

```
{1,2,3},{4,5},{6,7}
```

返回值：

```
{6,7}
```

说明：

```
第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分
这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的          
```

## 示例2

输入：

```
{1},{2,3},{}
```

返回值：

```
{}
```

说明：

```
2个链表没有公共节点 ,返回null，后台打印{}  
```





## 题解

题目抽象：给定两个单链表`A，B`，假设一定含有公共结点，返回第一个公共结点的指针。

## 方法：双指针法

假如例子如下：
![图片说明](https://uploadfiles.nowcoder.com/images/20200420/284295_1587392850228_ACBD8BAF88DF6904BFB7AA22E649D51E)
显然第一个公共结点为`8`，但是链表`A`头结点到`8`的长度为`2`，链表`B`头结点到`8`的长度为`3`，显然不好办？
如果我们能够制造一种理想情况，如下：
![图片说明](https://uploadfiles.nowcoder.com/images/20200420/284295_1587393149917_2A59DC6CAD5F95437BDAA4B2C919EB92)
这里先假设链表`A`头结点与结点`8`的长度 与 链表`B`头结点与结点`8`的长度相等，那么就可以用双指针。

1. 初始化：指针`ta`指向链表`A`头结点，指针`tb`指向链表`B`头结点
2. 如果`ta == tb`， 说明找到了第一个公共的头结点，直接返回即可。
3. 否则，`ta != tb`，则`++ta，++tb`

所以现在的问题就变成，如何让本来长度不相等的变为相等的？
假设链表`A`长度为`a`， 链表`B`的长度为`b`，此时`a != b`
但是，`a+b == b+a`
因此，可以让a+b作为链表A的新长度，b+a作为链表B的新长度。
如图：
![图片说明](https://uploadfiles.nowcoder.com/images/20200420/284295_1587394616610_37C15C411477833D2C2325823D927212)
这样，长度就一致了，可以用上述的双指针解法了。

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
         ListNode *ta = pHead1, *tb = pHead2;
         while (ta != tb) {
            ta = ta ? ta->next : pHead2;
            tb = tb ? tb->next : pHead1;
         }
        return ta;
    }
};
```

时间复杂度：O(m+n), m，n分别为链表A，B的长度，最坏情况下，公共结点为最后一个，需要遍历m+n个结点
空间复杂度：O(1)