# JZ70矩阵覆盖

---

## 描述

我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？

数据范围：0 $\le$ n $\le$ 38
进阶：空间复杂度 O(1) ，时间复杂度 O(n)

注意：约定 n == 0 时，输出 0

比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)：

![img](https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995)

### 输入描述：

2*1的小矩形的总个数n

### 返回值描述：

覆盖一个2*n的大矩形总共有多少种不同的方法(从同一个方向看)

## 示例1

输入：

```
0
```

返回值：

```
0
```

## 示例2

输入：

```
1
```

返回值：

```
1
```

## 示例3

输入：

```
4
```

返回值：

```
5
```



## 题解

### 方法一：递推

对于这种题没有思路怎么办？

那就对n 从小到大，一步步分析：

![img](https://uploadfiles.nowcoder.com/images/20200401/284295_1585751540081_03C53A5AC62A88D9EB8990F3AA07A674)

n=1时，显然只有一种方法

![img](https://uploadfiles.nowcoder.com/images/20200401/284295_1585751486593_A6173D096F46D2945BD37A57FD0B13B7)

n=2时，如图有2种方法

![img](https://uploadfiles.nowcoder.com/images/20200401/284295_1585751689995_1A7ED101D0E864141D8994EE961E829A)

n=3，如图有3中方法

# ![img](https://uploadfiles.nowcoder.com/images/20200401/284295_1585751938084_F5BD0B08BBFA91BD85A9E61F3F0710F3)

n=4,如图有5种方法。

如果到这里，还没有发现规律怎么办呢？

那我们就再分析以下，从n=3到n=4，怎么来的呢？

这里有2种情况：

- 直接在n=3的情况下，再后面中添加一个竖着的。这个很显然成立，有3种情况
- 然后横着的显然能添加到n-2的情况上，也就是在n=2后面，添加2个横着的。有2种情况

通过以上分析，发现刚好和图中的个数一样。

所以总结：f [n]表示2*n大矩阵 的方法数。

可以得出：f[n] = f[n-1] + f[n-2]，初始条件f[1] = 1, f[2] =2

所以代码可用递归，记忆递归，和动态规划和递推

这里只写递推代码：

```cpp
class Solution {
public:
    int rectCover(int n) {
        if (n==0 || n==1 || n==2) return n;
        int a = 1, b = 2, c;
        for (int i=3; i<=n; ++i) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
};

```

