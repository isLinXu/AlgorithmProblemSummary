# JZ68二叉搜索树的最近公共祖先

---



## 描述

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.

2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值

3.所有节点的值都是唯一的。

4.p、q 为不同节点且均存在于给定的二叉搜索树中。

数据范围:

3<=节点总数<=10000

0<=节点值<=10000

如果给定以下搜索二叉树: {7,1,12,0,4,11,14,#,#,3,5}，如下图:

![img](https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A)

## 示例1

输入：

```
{7,1,12,0,4,11,14,#,#,3,5},1,12
```

返回值：

```
7
```

说明：

```
节点1 和 节点12的最近公共祖先是7   
```

## 示例2

输入：

```
{7,1,12,0,4,11,14,#,#,3,5},12,11
```

返回值：

```
12
```

说明：

```
因为一个节点也可以是它自己的祖先.所以输出12   
```





## 题解

思路：
1.都在左边，或者都在右边，否则有一个就是我，直接跳出，返回我；
2.递归调用

```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    int ret=0;
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        // write code here
        TreeNode* cur=root;
        while(1){
            if(p<cur->val && q<cur->val)
                cur=cur->left;
            else if(p>cur->val && q>cur->val)
                cur=cur->right;
            else break;
        }
        return cur->val;
    }
};
```

