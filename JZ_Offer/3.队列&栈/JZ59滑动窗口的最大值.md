# JZ59滑动窗口的最大值

---

## 描述

给定一个长度为 n 的数组 nums 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。

例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

数据范围： 1 $\le$ size $\le$ n $\le$ 10000，数组中每个元素的值满足 |val| $\le$ 10000。

要求：空间复杂度 O(n)，时间复杂度 O(n)。



## 示例1

输入：

```
[2,3,4,2,6,2,5,1],3
```

返回值：

```
[4,4,6,6,6,5]
```

## 示例2

输入：

```
[9,10,9,-7,-3,8,2,-6],5
```

返回值：

```
[10,10,9,8]
```

## 示例3

输入：

```
[1,2,3,4],3
```

返回值：

```
[3,4]
```





## 题解

题目描述：给定一个数组num和一个窗口大小size，求每个窗口的最大值。

## 方法一：暴力方法

根据题目描述，我们很容易想到暴力方法。并且也很轻松的就可以写出来。如果数组的大小是n，窗口的大小是size，那么窗口的数量就是 n - size + 1.
算法步骤如下：

- 枚举每个窗口的左边界 i
- 根据窗口的左边界i可以对应计算出右边界j
- 遍历窗口，计算出最大值

代码如下：

```cpp
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& nums, int size) {
        vector<int> ret;
        if (nums.size() == 0 || size < 1 || nums.size() < size) return ret;
        int n = nums.size();
 
        for (int i = 0; i + size - 1 < n; ++i) {
            int j = i + size - 1;
            int max_val = nums[j];
            for (int k = i; k < j; ++k) {
                max_val = max(max_val, nums[k]);
            }
            ret.push_back(max_val);
        }
        return ret;
    }
};
```

时间复杂度：O(n*k), 其中n为数组大小，k为窗口大小
空间复杂度：O(1)，存结果必须要开的数组不算入额外空间



## 方法二：单调队列

方法一种存在很多大量重复计算，比如说，对于数组，假设我们当前遍历到下标i，对于下标i+1的元素（假设i和i+1都在同一个窗口），如果比arr[i]大，说明了什么？
如果arr[i+1] 已经大于了 arr[i], 那么还要arr[i]有什么用.就有点“既生瑜何生亮”的感觉。
如果arr[i+1] < arr[i]呢？显然arr[i]还是需要保留的。为什么呢？
因为又可以arr[i] 对于下一个arr[i+1]所在的窗口来说，arr[i]已经失效了。

假设这里有那么一个容器可以保留上述操作。

1. 遍历数组的每一个元素，
2. 如果容器为空，则直接将当前元素加入到容器中。
3. 如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续讲当前元素和容器的最后一个元素比较
4. 如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾
5. 如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除

总结一下，首先容器中放的元素应该是单调递减的。然后还有删除容器头部元素和最后一个元素的操作。因此，这样的数据结构就是双端队列。c++中就是`deque`

如何判断队列中头部的元素是否过期呢？
这里我们可以存数组的下标，根据下标的比较来判断。比如，当前遍历到下标为5的元素，窗口的大小为3， 显然显然下标为2的已经过期了。

代码如下：

```cpp
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> ret;
        if (num.size() == 0 || size < 1 || num.size() < size) return ret;
        int n = num.size();
           deque<int> dq;
           for (int i = 0; i < n; ++i) {
               while (!dq.empty() && num[dq.back()] < num[i]) {
                   dq.pop_back();
               }
               dq.push_back(i);
               // 判断队列的头部的下标是否过期
               if (dq.front() + size <= i) {
                   dq.pop_front();
            }
            // 判断是否形成了窗口
               if (i + 1 >= size) {
                   ret.push_back(num[dq.front()]);
               }
           }
           return ret; 
    }
};
```

