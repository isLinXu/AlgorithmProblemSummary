# 哈希函数

---

**要求：**

- 以结点的关键字值为参数，函数值是元素的存储位置
- 如果数组大小是n，哈希函数的值域为00 ~ n-1

**哈希函数的选择标准：**

- 计算速度快
- 散列地址尽可能均匀，使得冲突机会尽可能的少

**常用的哈希函数：**

- 直接地址法

  `H(key) = key` 或 `H(key) = a * key ＋ b`

  如：关键字集合为{100，400，600，200，800，900}

  取散列函数为`H（x）= key`，则需要901个单元

  取`H(x) = x/100`，需要10个单元。

- 除留取余法

  - 保证函数值是一个合法的下标

    `H(key)= key MOD p` ，`p`是数组的大小

    `p`最好为质数，函数值分布更均匀

  - 选取质数原因的例子：

    - 设 `key` 值都为奇数，选 `p` 为偶数；则 `H(key) = key MOD p` ，结果为奇数，一半单元被浪费掉。
    - 设 `key` 值都为 55 的倍数，选 `p` 为 9595；则 `H(key) = key MOD p` ，结果为：00、 55、1010、1515、…… 9090 。4/5的单元被浪费掉。

- 数字分析法

  对关键字集合中的所有关键字，分析每一位上数字分布；取数字分布均匀的位作为地址的组成部分

- 平方取中法

  - 适用于关键字中各位的分布都比较均匀，但关键字的值域比数组规模大

    将关键字平方后，取其结果的中间各位作为散列函数值

    由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大

  - 例子：

    关键字是4371，则计算4731 * 4731 = 22382361。

    中间部分究竟要选取几位，依赖于散列表的单元总数。

    若散列表总共有100个单元，可以选取最中间的部分，即第4、54、5位，那么关键字值为4731的结点的散列地址可选为82。

- 折叠法

  - 如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法。

    选取一个长度后，将关键字按此长度分组相加

  - 例子：

    关键字值为542242241，按33位折叠，可以得到542+242+241=1025

    抛弃进位，得到散列结果为25



## 练习

### 老菲林的疑问

老菲林经营着一家公司，这家公司里每位员工都有一个编号，有些干员外出执行任务，现在并不在公司本部，老菲林现在先要查询一些员工现在是否在公司本部，但是干员太多了，老菲林记不清楚，请你设计一个程序帮她查询一下。为了保证查询的准确性，技术部的希尔可露告诉你，老菲林想要询问的干员编号，在模大质数`19260817`的剩余系下，是不会重复的。

输入描述：

第一行两个整数`n m`，分别表示当前在公司的干员数量和老菲林的查询次数。

第二行`n (1 ≤ n ≤ 10^5)`个整数，表示当前在公司的干员编号，每个整数间用空格分开。

第三行`m (1 ≤ m ≤ 10^5)`个整数，表示当前老菲林查询的干员编号，每个整数间用空格分开。

注意：干员的编号有可能超过`int`的存储范围。

输出描述：

`m`行，每行一个整数，对应查询的结果。

若该干员在本部，则输出`yes`；反之，则输出`no`。

示例 1：

输入：

```
3 2
1 2 3
1 10
```

输出：

```
yes
no
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

#define mo 19260817 

long long vis[mo];

int main() {
    // 请补全代码，实现题目功能
    int n, m;
    long long t;
    cin >> n >> m;
    while (n--) {
        cin >> t;
        vis[t % mo] = t;
    }
    while (m--) {
        cin >> t;
        if (vis[t % mo] == t)
            cout << "yes" << endl;
        else
            cout << "no" << endl;
    }
    return 0;
}
```





