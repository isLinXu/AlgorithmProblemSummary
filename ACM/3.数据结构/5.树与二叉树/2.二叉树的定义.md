# 二叉树的定义

---

二叉树（Binary Tree）是结点的有限集合，它或者为空，或者由一个根结点及两棵互不相交的左、右子树构成，而其左、右子树又都是二叉树。

注意：二叉树必须严格区分左右子树。即使只有一棵子树，也要说明它是左子树还是右子树。交换一棵二叉树的左右子树后得到的是另一棵二叉树。

**满二叉树：** 一棵高度为k并具有$2^k－1$个结点的二叉树称为满二叉树。

**完全二叉树：** 在满二叉树的最底层自右至左依次(注意：不能跳过任何一个结点)去掉若干个结点得到的二叉树也被称之为完全二叉树。满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。

特点：

1. 所有的叶结点都出现在最低的两层上。
2. 对任一结点，如果其右子树的高度为k，则其左子树的高度为k或k＋1。



## 二叉树的遍历

按递归的观点，二叉树有左子树、右子树和根结点，按需遍历这三个部分。遍历的方法：

**前序**

如果二叉树为空，则操作为空；否则

- 访问根结点
- 前序遍历左子树
- 前序遍历右子树

**中序**

如果二叉树为空，则操作为空；否则

- 中序遍历左子树
- 访问根结点
- 中序遍历右子树

**后序**

如果二叉树为空，则操作为空；否则

- 后序遍历左子树
- 后序遍历右子树
- 访问根结点

**层次遍历**

- 先访问根结点，然后按从左到右的次序访问第二层的结点。在访问了第k层的所有结点后，再按从左到右的次序访问第k+1层。以此类推，直到最后一层。



## 总结

### 二叉树的概念

- 二叉树（Binary Tree）是结点的有限集合，它或者为空，或者由一个根结点及两棵互不相交的左、右子树构成，而其左、右子树又都是二叉树。
  - 注意：二叉树必须严格区分左右子树。即使只有一棵子树，也要说明它是左子树还是右子树。交换一棵二叉树的左右子树后得到的是另一棵二叉树。

![img](https://staticcdn.boyuai.com/user-assets/396/a6LFfaX1L8Q1vguNyQoxP5/2.jpg!jpg)

- 满二叉树
  - 一棵高度为k*k*并具有2^k－12*k*－1个结点的二叉树称为满二叉树。
- 完全二叉树：
  - 在满二叉树的最底层自右至左依次(注意：不能跳过任何一个结点)去掉若干个结点得到的二叉树也被称之为完全二叉树。满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。
  - 特点：
    - 所有的叶结点都出现在最低的两层上。
    - 对任一结点，如果其右子树的高度为k*k*，则其左子树的高度为k*k*或k＋1*k*＋1。

![img](https://staticcdn.boyuai.com/user-assets/396/j4zMXmy1SxBN74RBLCCWFL/3.jpg!jpg) ![img](https://staticcdn.boyuai.com/user-assets/396/rJRPPBUGBeqaiqjqmSNpKe/4.jpg!jpg)

### 二叉树的基本操作

- 建树`create()`：创建一棵空的二叉树

- 清空`clear()`：删除二叉树中的所有结点

- 判空`IsEmpty()`：判别二叉树是否为空树

- 求树的规模`size()`：统计树上的结点数

- 找根结点`root()`：找出二叉树的根结点值；如果树是空树，则返回一个特殊值

- 找父结点`parent(x)`：找出结点x的父结点值；如果x不存在或x是根，则返回一个特殊值

- 找左孩子`lchild(x)`：找结点x的左孩子结点值；如果x不存在或x的左儿子不存在，则返回一个特殊值

- 找右孩子`rchild(x)`：找结点x的右孩子结点值；如果x不存在或x的右儿子不存在，则返回一个特殊值

- 删除左子树`delLeft(x)`：删除结点x的左子树

- 删除右子树`delRight(x)`：删除结点x的右子树

- 前序遍历

  ```
  preOrder()
  ```

  ：前序遍历二叉树上的每一个结点

  - 如果二叉树为空，则操作为空；否则：
    - 访问根结点
    - 前序遍历左子树
    - 前序遍历右子树

- 中序遍历

  ```
  midOrder()
  ```

  ：中序遍历二叉树上的每一个结点

  - 如果二叉树为空，则操作为空；否则：
    - 中序遍历左子树
    - 访问根结点
    - 中序遍历右子树

- 后序遍历

  ```
  postOrder()
  ```

  ：后序遍历二叉树上的每一个结点

  - 如果二叉树为空，则操作为空；否则：
    - 后序遍历左子树
    - 后序遍历右子树
    - 访问根结点

- 层次遍历

  ```
  levelOrder()
  ```

  ：层次遍历二叉树上的每个结点

  - 先访问根结点，然后按从左到右的次序访问第二层的结点。在访问了第k层的所有结点后，再按从左到右的次序访问第k+1层。以此类推，直到最后一层。

我们可以通过**前序＋中序遍历确定一棵二叉树**：

- 找出根结点，区分左右子树
- 继续对左右子树重复这个过程
- 右子树只有根结点
- 找出左子树的前序、中序序列

### 二叉树抽象类

```C++
template<class T>
class bTree {
public:
    virtual void clear() = 0;
    virtual bool isEmpty() const = 0;
    virtual int size() const = 0;
    virtual T Root(T flag) const = 0;
    virtual T parent(T x， T flag) const = 0; 
    virtual T lchild（T x, T flag) const = 0;
    virtual T rchild（T x, T flag) const = 0;
    virtual void delLeft(T x) = 0;
    virtual void delRight(T x) = 0;
    virtual void preOrder() const = 0;
    virtual void midOrder() const = 0;
    virtual void postOrder() const= 0;
    virtual void levelOrder() const = 0;
    virtual bTree() {}
};
```



