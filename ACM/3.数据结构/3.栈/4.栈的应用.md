# 栈的应用

---

## 1、递归函数的非递归实现

递归：递归是一种特殊的函数调用，是在一个函数中又调用了函数本身。递归程序的本质是函数调用，而函数调用是要花费额外的时间和空间。在系统内部，函数调用是用栈来实现，如果程序员可以自己控制这个栈，就可以消除递归调用。

递归消除方法：

定义一个存放子问题的栈

把整个问题放入栈中

While (栈非空)

  执行解决问题的过程，分解出的小问题进栈



测试1

若某程序如下，分解写出函数入栈次序。（不包括main函数，填一串小写字符串，如acdca）

```cpp
void A(){C();D();}
void B(){D();}
void C(){B();}
void D(){}
int main()
{
    A();
    C();
}
```

```
acbddcbd
```



测试2

若某程序如下，分解写出函数出栈次序。（不包括main函数，填一串小写字符串，如acdca）

```cpp
void A(){C();D();}
void B(){D();}
void C(){B();}
void D(){}
int main()
{
    A();
    C();
}
```

```
dbcdadbc
```



## 2、快速排序的非递归实现

**思想：**

设置一个栈，记录要做的工作，即要排序的数据栈。

**操作步骤**

```
先将整个数组进栈，然后重复下列工作，直到栈空：
    从栈中弹出一个元素，即一个排序区间。
    将排序区间分成两半。
    检查每一半，如果多于两个元素，则进栈。
```



完成下列使用非递归实现快速排序的代码。

```
void quicksort(int* array,int left,int right)
{
	stack<int> s;
	s.push(left);
	s.push(right);
	while(!s.empty)
	{
		int right = s.top();
		s.pop();
		int left = s.top();
		s.pop();
		
		int index = partsort(array,left,right);
		if((index - 1) > left)
		{
			s.push(left);
			s.push(index - 1);
		}
		if((index + 1) < right)
		{
			s.push(index + 1);
			s.push(right);
		}
	}
}
```



## 3、括号配对检查

问题提出：编译程序的任务之一，就是检查括号是否配对。圆括号、方括号、花括号、单引号和双引号以及注释/*...*/都要配对。

简单地用开括号和闭括号的数量是否相等来判断开括号与闭括号是否配对是不行的。例如，符号串[（）]是正确的，而符号串（ [ ）]是不正确的。因为当遇到）那样的闭括号时，它与最近遇到开括号匹配。

**正确的做法**：

遇到右括号时，需要与最近遇到的、没有匹配的左括号匹配。

使用栈，遇到左括号进栈；见遇到右括号，则出栈，并比较两者是否配对。

**算法**：

1.首先创建一个空栈。

2.从源程序中读入符号。

3.如果读入的符号是开符号，将其进栈。

4.如果读入的符号是一个闭符号但栈是空的，出错。否则，将栈中的符号出栈。

5.如果出栈的符号和和读入的闭符号不匹配，出错。

6.继续从文件中读入下一个符号，非空则转向3，否则执行7。

7.如果栈非空，报告出错，否则括号配对成功。

**C++的特殊情况**：

至少需要考虑三种括号：圆括号、方括号和花括号。

如果括号出现在注释、字符串常量、字符常量中时，就不需要考虑。

**匹配问题**

在考虑单引号、双引号时，还必须考虑转义字符。



## 4、Balance类的设计

**设计要求：**

检查一个C++源程序中括号是否配对。要求对象初始化时传给它一个源文件名，成员函数checkBalance 检查源文件中的符号是否配对，输出所有不匹配的符号及所在的行号和输出总的错误数。

**设计考虑：**

数据成员：需要检查的源文件名：文件流对象；行号；错误数

成员函数：构造函数；检查括号配对函数



## 5、checkBalance的实现

算法参考6。

进一步需要细化：

读文件，直到读入一括号；输出某行某符号不匹配；出错数加1；检查lastChar与match是否匹配。如不匹配，输出出错信息，出错数加1；栈中元素均没有找到匹配的闭符号，输出这些错误。

进一步抽取子函数：

第1项工作： GetNextSymbol

功能：从文件的当前位置开始，跳过所有的非括号，读到第一个括号后返回。在遇到文件结束时，返回一个特定的符号，如NULL。

函数原型：函数有一个字符型的返回值。执行该函数必须有一个输入流，在读输入流的过程中，当前处理的行号会变，在读的过程中也可能遇到异常情况，因此出错数也会变。这三个信息：文件流对象，当前处理的行号，出错个数都是对象的数据成员。因此函数原型为：char GetNextSymbol（）。

第3项工作：CheckMatch

功能：比较两个指定位置的待比较的符号是否匹配

函数原型：bool balance::CheckMatch(char Symb1, char Symb2, int Line1, int Line2 )



## 6、GetNextSymbol的实现

功能：从文件的当前位置开始，跳过所有的非括号，读到第一个括号后返回。在遇到文件结束时，返回一个特定的符号，如NULL。

特殊情况：

注释中的括号不用考虑

字符串常量和字符常量中的括号不用考虑。

C++中的注释又有两种形式

以“//”开始到本行结束

以“/*”开始到“*/”结束，可以跨行



## 7、其他函数与实现

- NextChar 的实现：从输入文件流中读入一个字符，返回给调用程序，遇到文件结束符，返回NULL。如遇到换行符，则当前处理行加1。
- PutBackChar 的实现：将传入的字符放回输入流，这是通过调用输入流对象的成员函数putback实现的。如放回的字符是回车，当前处理行号减1。
- SkipQuote的实现：读文件，直到读到一个和参数值相同的符号。
  - 特殊情况：字符或字符串常量不允许跨行的、转义字符的处理
- SkipComment的实现：分辨注释类型并完成跳过注释的任务：
  - 如果是以“//”开头的注释，则不断地读文件直到遇到换行或文件结束符
  - 如果是以“/*”开头的注释，则必须读到“*/”为止。
  - 在第二种注释中，判断注释是否结束要判断连续的两个符号，因此用一个变量flag保存前一次读到的符号。





## 8、后缀表达式

中缀表达式：运算符是处于运算数的中间，如(a + b) * c /( d - e)。

后缀表达式：运算符在运算数后面，上式变为a b + c * d e - /。

后缀表达式的计算：顺序扫描表达式，遇到运算符，将前面离它最近的两个运算数进行运算。

后缀表达式的计算实现：

1初始化一个栈。

2依次读入后缀式的操作数和运算符直到结束

若读到的是操作数，则将其进栈。

若读到的是运算符，则将栈顶的两个操作数出栈，后弹出的操作数为被操作数，先弹出的为操作数，将得到的操作数完成运算符所规定的运算，并将结果进栈。

3当栈中只剩有一个操作数时，弹出该操作数，它就是表达式的值。

计算后缀表达式9 4 2 * - 3 5 + * 8 / 7 3 % - 。

```
0
```



## 9、中缀转后缀

中缀和对应后缀式的共性：运算数次序不变，根据优先级调整运算符的位置。

中缀转后缀算法(考虑只包含加、减、乘、除运算)：

1.遍历中缀表达式

若读入的是操作数，立即输出。

若读入的是闭括号，则将栈中的运算符依次出栈并输出，直到遇到相应的开括号，将开括号出栈。

若读入的是开括号，则进栈。

若读入的是运算符，如果栈顶运算符优先级高于或等于读入的运算符，则栈顶运算符出栈；直到栈顶运算符优先级低于读入的运算符为止，读入的运算符进栈。

2.在读入操作结束时，将栈中所有的剩余运算符依次出栈并输出，直至栈空为止。



写出中缀表达式`(a+b) * (c-d*e)^f - (g/h+i)`对应的后缀表达式。

```
ab+cde*-f^*gh/i+-
```



## 10、计算器类的实现

问题：输入一个中缀表达式,计算的对象为类型为int的正整数，能计算加、减、乘、除和乘方运算，允许用括号改变优先级。

calc类的设计:

数据成员:一个字符串，用于保存表达式

公有成员函数：构造和析构函数\计算表达式结果\赋值运算符重载


## 11、result函数的实现

**实现思想:**

计算器中的表达式中的运算数都是常量，没有必要先转换成后缀表达式，在计算后缀表达式的值。可以将转换和计算两个步骤合并起来，边转换边计算。 即在中缀转后缀时，发现某个运算符可以出栈时，则直接执行运算。 运算过程需要用到两个栈：中缀表达式转后缀表达式时的运算符栈，执行后缀表达式运算时的运算数栈。

伪代码：

```c++
int calc::result()
{
    依次从表达式中取出一个合法的符号，直到表达式结束 {
        switch(当前符号) {
            case  数字：将数字存入运算数栈；
            case ‘(’: 开括号进运算符栈;
            case ‘)’: 开运算符栈中的运算符依次出栈并执行运算，直到‘（’出栈；
            case ‘^’: 乘方运算符进运算符栈；
            case ‘*’: case ‘/’: 运算符栈中的/、*、^退栈并执行相应的运算，当前运算符进栈；
            case ‘+’:case ‘-’: 运算符栈中的运算符依次出栈执行相应的运算，直到栈为空或遇到开括号。当前运算符进栈；
        }
    }  
    运算符栈中在所有的运算符出栈执行；
    if (运算数栈为空） 出错，无运算结果 ；
    result_value = 运算数栈出栈元素；
    if （运算数栈非空） 出错，缺运算符 ；
    return result_value ;
}
```

考虑进一步细化：在上述伪代码中，大多数的操作都是进栈出栈，这些操作在栈类中都已实现。除此之外，还有两个操作需要细化： 从表达式中取出一个合法的符号：

```c++
token getOp(int &value);
```

执行一个算术运算：

```c++
void BinaryOp(token op,  seqStack<int> &dataStack)；
```





## 12、私有函数的实现

类中的私有函数：

从表达式中取出一个合法的符号：

```cpp
token getOp(int &value);
```

执行一个算术运算：

```cpp
void BinaryOp(token op, seqStack<int> &dataStack)；
```

**getOp的实现：**

如果是运算符，根据不同的运算符返回不同的token类型的值。 如果是运算数，则取出这个运算数，转换成整型数存入参数value，返回符号VALUE。 很多程序员在写算术表达式时都习惯在运算符的前后插入一些空格，使表达式看上去更加清晰。这些空格对表达式的计算是没有意义的，在扫描过程中要忽略这些空格。



## 总结

栈的一个主要应用就是把递归函数转换成非递归函数。

### 递归函数调用过程

- 递归是一种特殊的函数调用，是在一个函数中又调用了函数本身。
- 递归程序的本质是函数调用，而函数调用是要花费额外的时间和空间。
- 在系统内部，函数调用是用栈来实现。

![img](https://staticcdn.boyuai.com/user-assets/396/EHA3LMK9XczfZEcuNPTSfu/1638695022267.jpg!jpg)

### 递归消除方法

如果程序员可以自己控制程序调用的栈，就可以消除递归调用。

方法如下:

```pseudocode
定义一个存放子问题的栈
把整个问题放入栈中
While (栈非空)  
    执行解决问题的过程，分解出的小问题进栈
```

### 举例：快速排序的非递归实现

- 快排函数的递归实现:

```c++
void quicksort(int a[], int low, int high) {
    int mid;

    if (low >= high) return;

    mid = divide(a, low, high);
    quicksort( a, low, mid-1);
    quicksort( a, mid+1, high);
}
```

- 快排非递归实现的思想：

  - 设置一个栈，记录要做的工作，即要排序的数据栈。
  - 栈里面的每个元素为一个`node`，有`left`和`right`两个成员，表示对下标从left到right这一部分数据进行排序。
  - 操作步骤:

  ```pseudocode
  先将整个数组进栈
  重复下列工作，直到栈空：
      从栈中弹出一个元素，即一个排序区间。
      将排序区间分成两半。
      检查每一半，如果多于两个元素，则进栈。
  ```

- 快排非递归实现的过程：

  - 左边表示要排序的数组，右边表示我们的栈里面的内容。

![img](https://staticcdn.boyuai.com/user-assets/396/zuEYjkY732hQpD8qpPE1wY/1638762976764.jpg!jpg)

- 快排非递归实现的代码：

```c++
// 每个node表示要对从left到right这一部分数据进行排序
struct  node {
    int left;
    int right;
};

void quicksort( int a[],  int size) { 
    seqStack <node> st;
    int mid, start, finish;
    node s;

    if (size <= 1) return;

    // 排序整个数组
    s.left = 0; 
    s.right = size - 1;
    st.push(s);
    while (!st.isEmpty())  {
        s = st.pop(); 
        start = s.left;
        finish = s.right; 
        mid = divide(a, start, finish);
        if (mid - start > 1) { 
            s.left = start; 
            s.right = mid - 1; 
            st.push(s); 
        }
        if (finish - mid > 1) { 
            s.left = mid + 1; 
            s.right = finish;
            st.push(s)；
        }
    }
}
```





## 练习

### 表达式括号匹配

假设一个表达式有英文字母（小写）、运算符`+ — * /`和左右小（圆）括号构成，以`@`作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则返回`YES`；否则返回`NO`。表达式长度小于255，左圆括号少于20个。

输入描述：

一行，输入的表达式。



输出描述：

一行，`YES`或`NO`


示例 1：

输入：

```
2*(x+y)/(1-x)@
```

输出：

```
YES
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std;

char s[1010];

int main() {
    // 请补全代码，实现题目功能
    int a = 0;
    scanf("%s", s);
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        if (s[i] =='(') {
            a++;
        }
        if (s[i] == ')') {
            a--;
            if (a < 0) {
                printf("NO");
                return 0;
            }
        }
    }
    if (a == 0)
        printf("YES");
    else
        printf("NO");
    return 0;
}
```



输入

```
2*(x+y)/(1-x)@
```

输出

```
YES
```

预期结果

```
YES
```





