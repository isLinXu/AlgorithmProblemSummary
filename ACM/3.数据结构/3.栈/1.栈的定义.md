# 栈的定义

---

## **栈的定义：** 

栈是一种运算受限的线性表，在这种线性表上的插入和删除运算限定在某一处进行。允许进行插入和删除操作的一端被称为栈顶，相对地，把另一端称为栈底。这是一种后进先出(LIFO, Last In First Out)或先进后出(FILO, First In Last Out)结构，最先(晚)到达栈的结点将最晚(先)被删除。


## **栈的运算：**

- 创建一个栈create()：创建一个空的栈；
- 进栈push(x)：将x插入栈中，使之成为栈顶元素；
- 出栈pop()：删除栈顶元素并返回栈顶元素值；
- 读栈顶元素top()：返回栈顶元素值但不删除栈顶元素；
- 判栈空isEmpty()：若栈为空，返回true，否则返回false。



## **栈的顺序实现：**

用连续的空间存储栈中的结点，即数组。 下标为0的一端为栈底。 进栈和出栈总是在栈顶一端进行，不会引起类似顺序表中的大量数据的移动。

### **运算函数：**

构造函数：按照用户估计的栈的规模申请一个动态数组。

push(x)：将top_p加1，将x放入top_p指出的位置中。但要注意数组满的情况。

pop()：返回top_p指出的位置中的值并将top_p减1。

top()：与pop类似，只是不需要将top_p减1。

isEmpty()：若top_p的值为-1，返回true，否则返回false。

### **性能分析：**

除了进栈操作以外，所有运算实现的时间复杂度都是O(1)。 进栈运算在最坏情况下的时间复杂度是O(N)。 均摊分析法：最坏情况在N次进栈操作中至多出现一次。如果把扩展数组规模所需的时间均摊到每个插入操作，每个插入只多了一个拷贝操作，因此从平均的意义上讲，插入运算还是常量的时间复杂度



## **栈的链接实现：**

由于栈的操作都是在栈顶进行的，因此用单链表就足够了，而且不需要头结点，因为对栈来讲只需要考虑栈顶元素的插入删除。从栈的基本运算的实现方便性考虑，可将单链表的头指针指向栈顶。

**运算函数**

构造函数：将top_p设为空指针。

析构函数：注意需要释放空间。

push(x)：在表头执行单链表的插入。

pop()：在表头执行单链表的删除。

top()：返回top_p指向的结点的值。

isEmpty()：判top_p是否为空指针。

**性能分析：**

由于所有的操作都是对栈顶的操作，与栈中的元素个数无关。所以，所有运算的时间复杂度都是O(1)。



## 栈的应用

### 1、递归函数的非递归实现

递归：递归是一种特殊的函数调用，是在一个函数中又调用了函数本身。递归程序的本质是函数调用，而函数调用是要花费额外的时间和空间。在系统内部，函数调用是用栈来实现，如果程序员可以自己控制这个栈，就可以消除递归调用。

递归消除方法：

定义一个存放子问题的栈

把整个问题放入栈中

While (栈非空)

  执行解决问题的过程，分解出的小问题进栈



#### 测试1

若某程序如下，分解写出函数入栈次序。（不包括main函数，填一串小写字符串，如acdca）

```cpp
void A(){C();D();}
void B(){D();}
void C(){B();}
void D(){}
int main()
{
    A();
    C();
}
```

```
acbddcbd
```



#### 测试2

若某程序如下，分解写出函数出栈次序。（不包括main函数，填一串小写字符串，如acdca）

```cpp
void A(){C();D();}
void B(){D();}
void C(){B();}
void D(){}
int main()
{
    A();
    C();
}
```

```
dbcdadbc
```



### 2、快速排序的非递归实现

**思想：**

设置一个栈，记录要做的工作，即要排序的数据栈。

**操作步骤**

```
先将整个数组进栈，然后重复下列工作，直到栈空：
    从栈中弹出一个元素，即一个排序区间。
    将排序区间分成两半。
    检查每一半，如果多于两个元素，则进栈。
```



完成下列使用非递归实现快速排序的代码。

```
void quicksort(int* array,int left,int right)
{
	stack<int> s;
	s.push(left);
	s.push(right);
	while(!s.empty)
	{
		int right = s.top();
		s.pop();
		int left = s.top();
		s.pop();
		
		int index = partsort(array,left,right);
		if((index - 1) > left)
		{
			s.push(left);
			s.push(index - 1);
		}
		if((index + 1) < right)
		{
			s.push(index + 1);
			s.push(right);
		}
	}
}
```



### 3、括号配对检查

问题提出：编译程序的任务之一，就是检查括号是否配对。圆括号、方括号、花括号、单引号和双引号以及注释/*...*/都要配对。

简单地用开括号和闭括号的数量是否相等来判断开括号与闭括号是否配对是不行的。例如，符号串[（）]是正确的，而符号串（ [ ）]是不正确的。因为当遇到）那样的闭括号时，它与最近遇到开括号匹配。

**正确的做法**：

遇到右括号时，需要与最近遇到的、没有匹配的左括号匹配。

使用栈，遇到左括号进栈；见遇到右括号，则出栈，并比较两者是否配对。

**算法**：

1.首先创建一个空栈。

2.从源程序中读入符号。

3.如果读入的符号是开符号，将其进栈。

4.如果读入的符号是一个闭符号但栈是空的，出错。否则，将栈中的符号出栈。

5.如果出栈的符号和和读入的闭符号不匹配，出错。

6.继续从文件中读入下一个符号，非空则转向3，否则执行7。

7.如果栈非空，报告出错，否则括号配对成功。

**C++的特殊情况**：

至少需要考虑三种括号：圆括号、方括号和花括号。

如果括号出现在注释、字符串常量、字符常量中时，就不需要考虑。

**匹配问题**

在考虑单引号、双引号时，还必须考虑转义字符。



### 4、Balance类的设计

**设计要求：**

检查一个C++源程序中括号是否配对。要求对象初始化时传给它一个源文件名，成员函数checkBalance 检查源文件中的符号是否配对，输出所有不匹配的符号及所在的行号和输出总的错误数。

**设计考虑：**

数据成员：需要检查的源文件名：文件流对象；行号；错误数

成员函数：构造函数；检查括号配对函数



### 5、checkBalance的实现

算法参考6。

进一步需要细化：

读文件，直到读入一括号；输出某行某符号不匹配；出错数加1；检查lastChar与match是否匹配。如不匹配，输出出错信息，出错数加1；栈中元素均没有找到匹配的闭符号，输出这些错误。

进一步抽取子函数：

第1项工作： GetNextSymbol

功能：从文件的当前位置开始，跳过所有的非括号，读到第一个括号后返回。在遇到文件结束时，返回一个特定的符号，如NULL。

函数原型：函数有一个字符型的返回值。执行该函数必须有一个输入流，在读输入流的过程中，当前处理的行号会变，在读的过程中也可能遇到异常情况，因此出错数也会变。这三个信息：文件流对象，当前处理的行号，出错个数都是对象的数据成员。因此函数原型为：char GetNextSymbol（）。

第3项工作：CheckMatch

功能：比较两个指定位置的待比较的符号是否匹配

函数原型：bool balance::CheckMatch(char Symb1, char Symb2, int Line1, int Line2 )



### 6、GetNextSymbol的实现

功能：从文件的当前位置开始，跳过所有的非括号，读到第一个括号后返回。在遇到文件结束时，返回一个特定的符号，如NULL。

特殊情况：

注释中的括号不用考虑

字符串常量和字符常量中的括号不用考虑。

C++中的注释又有两种形式

以“//”开始到本行结束

以“/*”开始到“*/”结束，可以跨行



### 7、其他函数与实现

- NextChar 的实现：从输入文件流中读入一个字符，返回给调用程序，遇到文件结束符，返回NULL。如遇到换行符，则当前处理行加1。
- PutBackChar 的实现：将传入的字符放回输入流，这是通过调用输入流对象的成员函数putback实现的。如放回的字符是回车，当前处理行号减1。
- SkipQuote的实现：读文件，直到读到一个和参数值相同的符号。
  - 特殊情况：字符或字符串常量不允许跨行的、转义字符的处理
- SkipComment的实现：分辨注释类型并完成跳过注释的任务：
  - 如果是以“//”开头的注释，则不断地读文件直到遇到换行或文件结束符
  - 如果是以“/*”开头的注释，则必须读到“*/”为止。
  - 在第二种注释中，判断注释是否结束要判断连续的两个符号，因此用一个变量flag保存前一次读到的符号。





### 8、后缀表达式

中缀表达式：运算符是处于运算数的中间，如(a + b) * c /( d - e)。

后缀表达式：运算符在运算数后面，上式变为a b + c * d e - /。

后缀表达式的计算：顺序扫描表达式，遇到运算符，将前面离它最近的两个运算数进行运算。

后缀表达式的计算实现：

1初始化一个栈。

2依次读入后缀式的操作数和运算符直到结束

若读到的是操作数，则将其进栈。

若读到的是运算符，则将栈顶的两个操作数出栈，后弹出的操作数为被操作数，先弹出的为操作数，将得到的操作数完成运算符所规定的运算，并将结果进栈。

3当栈中只剩有一个操作数时，弹出该操作数，它就是表达式的值。

计算后缀表达式9 4 2 * - 3 5 + * 8 / 7 3 % - 。

```
0
```



### 9、中缀转后缀

中缀和对应后缀式的共性：运算数次序不变，根据优先级调整运算符的位置。

中缀转后缀算法(考虑只包含加、减、乘、除运算)：

1.遍历中缀表达式

若读入的是操作数，立即输出。

若读入的是闭括号，则将栈中的运算符依次出栈并输出，直到遇到相应的开括号，将开括号出栈。

若读入的是开括号，则进栈。

若读入的是运算符，如果栈顶运算符优先级高于或等于读入的运算符，则栈顶运算符出栈；直到栈顶运算符优先级低于读入的运算符为止，读入的运算符进栈。

2.在读入操作结束时，将栈中所有的剩余运算符依次出栈并输出，直至栈空为止。



写出中缀表达式`(a+b) * (c-d*e)^f - (g/h+i)`对应的后缀表达式。

```
ab+cde*-f^*gh/i+-
```



### 10、计算器类的实现

问题：输入一个中缀表达式,计算的对象为类型为int的正整数，能计算加、减、乘、除和乘方运算，允许用括号改变优先级。

calc类的设计:

数据成员:一个字符串，用于保存表达式

公有成员函数：构造和析构函数\计算表达式结果\赋值运算符重载


### 11、result函数的实现

**实现思想:**

计算器中的表达式中的运算数都是常量，没有必要先转换成后缀表达式，在计算后缀表达式的值。可以将转换和计算两个步骤合并起来，边转换边计算。 即在中缀转后缀时，发现某个运算符可以出栈时，则直接执行运算。 运算过程需要用到两个栈：中缀表达式转后缀表达式时的运算符栈，执行后缀表达式运算时的运算数栈。

伪代码：

```c++
int calc::result()
{
    依次从表达式中取出一个合法的符号，直到表达式结束 {
        switch(当前符号) {
            case  数字：将数字存入运算数栈；
            case ‘(’: 开括号进运算符栈;
            case ‘)’: 开运算符栈中的运算符依次出栈并执行运算，直到‘（’出栈；
            case ‘^’: 乘方运算符进运算符栈；
            case ‘*’: case ‘/’: 运算符栈中的/、*、^退栈并执行相应的运算，当前运算符进栈；
            case ‘+’:case ‘-’: 运算符栈中的运算符依次出栈执行相应的运算，直到栈为空或遇到开括号。当前运算符进栈；
        }
    }  
    运算符栈中在所有的运算符出栈执行；
    if (运算数栈为空） 出错，无运算结果 ；
    result_value = 运算数栈出栈元素；
    if （运算数栈非空） 出错，缺运算符 ；
    return result_value ;
}
```

考虑进一步细化：在上述伪代码中，大多数的操作都是进栈出栈，这些操作在栈类中都已实现。除此之外，还有两个操作需要细化： 从表达式中取出一个合法的符号：

```c++
token getOp(int &value);
```

执行一个算术运算：

```c++
void BinaryOp(token op,  seqStack<int> &dataStack)；
```





### 12、私有函数的实现

类中的私有函数：

从表达式中取出一个合法的符号：

```cpp
token getOp(int &value);
```

执行一个算术运算：

```cpp
void BinaryOp(token op, seqStack<int> &dataStack)；
```

**getOp的实现：**

如果是运算符，根据不同的运算符返回不同的token类型的值。 如果是运算数，则取出这个运算数，转换成整型数存入参数value，返回符号VALUE。 很多程序员在写算术表达式时都习惯在运算符的前后插入一些空格，使表达式看上去更加清晰。这些空格对表达式的计算是没有意义的，在扫描过程中要忽略这些空格。



## 总结

#### 栈的概念

- 栈是线性表的一种；
- 允许进行插入和删除操作的一端被称为栈顶，相对地，把另一端称为栈底；
- 这是一种后进先出(LIFO, Last In First Out)或先进后出(FILO, First In Last Out)结构，最先(晚)到达栈的结点将最晚(先)被删除。

![img](https://staticcdn.boyuai.com/user-assets/396/RZP8YSMwnjP9oebcvUYReP/%E5%9B%BE%E7%89%87%201.png!png)

#### 栈的基本操作

- 创建一个栈`create()`：创建一个空的栈；
- 进栈`push(x)`：将`x`**插入**栈中，使之成为栈顶元素；
- 出栈`pop()`：**删除**栈顶元素并返回栈顶元素值；
- 读栈顶元素`top()`：返回栈顶元素值但不删除栈顶元素；
- 判栈空`isEmpty()`：若栈为空，返回`true`，否则返回`false`。

#### 栈的抽象类

```c++
template <class elemType>
class stack {
    public: 
        virtual bool isEmpty() const = 0; 
        virtual void push(const elemType &x) = 0; 
        virtual elemType pop() = 0;              
        virtual elemType top() const = 0;
        // 虚析构函数防止内存泄漏
        virtual ~stack() {}
}; 
```







