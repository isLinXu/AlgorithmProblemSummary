# 位运算符与表达式

---

## 0和1组成的世界

> 钢琴通过黑键和白键编织出了一曲又一曲美妙的乐章，构建了一个如梦似幻世界。
>
> 而在计算机的世界中，0和1构成了千变万化的数据，帮我们实现了各种不可思议的功能。

![img](https://staticcdn.boyuai.com/user-assets/34/9peTEF3BqcE9PkqCwRaUAf/A05-2-p-0.png!png)

本节内容中，我们将学习C++中的位运算符与表达式，根据计算机数据的本源进行计算。



## C++按位运算符

本节内容将介绍C++中按位进行的运算符，简称**位运算**。

- 在计算机中，数据以二进制的形式储存
  - 每8位（bit）构成一个[字节](https://baike.baidu.com/item/位、字节、字/15650262?fr=aladdin)（byte）
  - 每个位具有`0`或`1`两种状态中的一种

Tips：通过多个字节组合，内存以二进制形式存放数值。例如，

- 字符类型`char`的常量7大小为1个字节
  - 存储为`8`位二进制数：`0000 0111`
- 整数类型`int`的常量7大小为4个字节
  - 存储为`32`位二进制数：`0000 0000 0000 0000 0000 0000 0000 0111`

C++中共包含6种**按位运算符**：

- 按位与运算符`&`
- 按位或运算符`|`
- 异或运算符`^`
- 按位取反运算符`~`
- 左移运算符`<<`
- 右移运算符`>>`

Tips：**按位运算符**只能对**字符整型**以及**数值整型**数据类型的**常量**或**变量**使用，不能对**浮点类型**数据进行计算。



## 位与运算符

- 按位与运算符`&`对两个操作数按照二进制位进行[与运算](https://baike.baidu.com/item/与/13025631?fromtitle=与运算&fromid=17712974&fr=aladdin)。

Tips：对于操作数`a`和`b`，下表演示了`&`运算符的工作方式：

![img](https://staticcdn.boyuai.com/user-assets/34/PgcdEpD85XoeRFdxDW6CC6/A05-2-p-1.png!png)

Tips：`&`运算符只有在两个操作数的对应位同时为`1`时，才会得到结果`1`。

举例：以变量`A = 60`，`B = 13`作为计算样例：

变量按位与运算符的程序段

```C++
int A = 60; // 0011 1100
int B = 13; // 0000 1101

cout << "A & B = " << (A & B) << endl;
```

对`A`和`B`按位进行与运算后，可以得到：

```
A & B = 0000 1100
```

二进制数`0000 1100`的值为`12`，故打印结果可得：

```
A & B = 12
```

你可以补充右侧代码区的`____`部分，输出变量`A`和变量`B`的按位与的结果。

```cpp
#include <iostream>
using namespace std;

int main() {
    int A = 60; // 0011 1100
    int B = 13; // 0000 1101
    
    // TODO 输出A和B按位与的结果
    cout << "A & B = " << (A & B) << endl;
    
    return 0;
}
```



## 位或运算符

- 按位或运算符`|`对两个操作数按照二进制位进行[或运算](https://baike.baidu.com/item/OR运算/20809564?fr=aladdin)。

Tips：对于操作数`a`和`b`，下表演示了`|`运算符的工作方式：

![img](https://staticcdn.boyuai.com/user-assets/34/knzRRcfo24gPnMGT4LiW4T/A05-2-p-2.png!png)

Tips：或运算只要在两个操作数的对应位存在`1`时，就可以得到结果`1`。

举例：以变量`A = 60`，`B = 13`作为计算样例：

变量按位或运算符的程序段

```C++
int A = 60; // 0011 1100
int B = 13; // 0000 1101

cout << "A | B = " << (A | B) << endl;
```

对`A`和`B`应用位或运算符进行计算，可以得到：

```
A | B = 0011 1101
```

二进制数`0011 1101`的值为`61`，故打印结果可得：

```
A | B = 61
```

你可以补充右侧代码区的`____`部分，输出变量`A`和变量`B`的按位或的结果。



## 位异或运算符

- 位异或运算符`^`对两个操作数按照二进制位进行[异或运算](https://baike.baidu.com/item/异或/10993677?fromtitle=异或运算&fromid=720417&fr=aladdin)。

Tips：对于操作数`a`和`b`，下面的真值表演示了`^`运算符的工作方式：

![img](https://staticcdn.boyuai.com/user-assets/34/jGdzXbrhwXm1kL9xnvDBBn/A05-2-p-3.png!png)

Tips：异或运算在两个操作数的对应位**不相同**时，会得到结果`1`；也可以看作是二进制下的**无进位相加**。

举例：以变量`A = 60`，`B = 13`作为计算样例：

变量按位或运算符的程序段

```C++
int A = 60; // 0011 1100
int B = 13; // 0000 1101

cout << "A ^ B = " << (A ^ B) << endl;
```

对`A`和`B`应用异或运算符进行计算，可以得到：

```
A ^ B = 0011 0001
```

二进制数`0011 0001`的值为`49`，故打印结果可得：

```
A ^ B = 49
```

你可以补充右侧代码区的`____`部分，输出变量`A`和变量`B`的按位异或的结果

```cpp
#include <iostream>
using namespace std;

int main() {
    int A = 60; // 0011 1100
    int B = 13; // 0000 1101
    
    // TODO 输出A和B按位异或的结果
    cout << "A ^ B = " << (A ^ B) << endl;
    
    return 0;
}
```



## 位取反运算符

- C++中，取反运算符`~`对单个二进制操作数按位进行[取反运算](https://baike.baidu.com/item/取反/12718166?fr=aladdin)。

Tips：二进制位取反规则是`0`变`1`，`1`变`0`。

举例：以变量`A = 60`作为计算样例

变量按位取反的程序段

```C++
int A = 60; // 0011 1100

cout << "~A = " << (~A) << endl;
```

对`A`应用取反运算符进行计算，可以得到：

```
~A = 1100 0011
```

- 在计算机中，所有的二进制数据都是用

  补码

  保存的。

  - 正数的补码就是

    原码本身

    - 正数变量`A`的原码为`0011 1100`，补码同样等于`0011 1100`。

  - 负数的补码是在其原码的基础上，

    符号位

    不变，其余各位

    取反

    然后

    ```
    +1
    ```

    - 负数变量`~A`的原码为`1100 0011`，补码等于`1011 1100 + 1 = 1011 1101`，值为`-61`，故`~A = -61`。

根据取反运算的规则，打印结果可得：

```
~A = -61
```

Tips：一个对操作数取反运算的简单规律是：会得到比原先操作数的相反数还小`1`的结果。

你可以补充右侧代码区的`____`部分，输出变量`A`按位取反的结果。

```cpp
#include <iostream>
using namespace std;

int main() {
    int A = 60; // 0011 1100
    
    // TODO 输出A按位取反的结果
    cout << "~A = " << (~A) << endl;
    
    return 0;
}
```



## 左右移运算符

- 在C++中，左移运算符`<<`可以将一个操作数的各二进制位全部左移若干位。
  - 左边多余的二进制位将被丢弃
  - 右边不足的二进制位将被补`0`

举例：以变量`A = 60`作为计算样例

变量左移运算的程序段

```C++
int A = 60; // 0011 1100

cout << "A << 1 = " << (A << 1) << endl;
```

对`A`应用左移运算符进行1次位移，可以得到：

```
A << 1 = 0111 1000
```

二进制数`0111 1000`的值为`120`，故打印结果可得：

```
A << 1 = 120
```

Tips：在结果符号位不改变，并且没有超过表示范围的情况下，左移运算符移动了几位，相当于对原操作数进行了几次乘`2`运算。

- 在C++中，

  右移运算符

  ```
  >>
  ```

  可以将一个操作数的各二进制位全部右移若干位。

  - 右侧多余的位将会被舍弃
  - 左侧对于无符号数，会在左侧补`0`
  - 左侧对于有符号数，会用符号位补齐：正数为`0`，负数为`1`

举例：以变量`A = 60`作为计算样例

变量右移运算的程序段

```C++
int A = 60; // 0011 1100

cout << "A >> 2 = " << (A >> 2) << endl;
```

对`A`应用右移运算符进行2次位移，可以得到：

```
A >> 2 = 0000 1111
```

二进制数`0111 1000`的值为`120`，故打印结果可得：

```
A >> 2 = 15
```

你可以补充右侧代码区的`____`部分，输出变量`A`左移1位和右移2位的结果。

```cpp
#include <iostream>
using namespace std;

int main() {
    int A = 60; // 0011 1100
    
    // TODO 输出A左移1位的结果
    cout << "A << 1 = " << (A << 1) << endl;
    // TODO 输出A右移2位的结果
    cout << "A >> 2 = " << (A >> 2) << endl;
    
    return 0;
}
```



## 总结

**位运算**是在数值的二进制形式表示下进行的运算，因此会涉及到许多特有的运算规则。C++中包含了6种按位运算符，分别为：

- **按位与运算符`&`**、**按位或运算符`|`**、**异或运算符`^`**

`&`、`|`、`^`都用于对两个二进制操作数，按照逐个位进行与运算。假设`a`和`b`是两个只能取二进制值即`1`和`0`的操作数，下表演示了这三个运算符的工作方式：

![img](https://staticcdn.boyuai.com/user-assets/34/PgcdEpD85XoeRFdxDW6CC6/A05-2-p-1.png!png) ![img](https://staticcdn.boyuai.com/user-assets/34/knzRRcfo24gPnMGT4LiW4T/A05-2-p-2.png!png) ![img](https://staticcdn.boyuai.com/user-assets/34/jGdzXbrhwXm1kL9xnvDBBn/A05-2-p-3.png!png)

令变量`A = 60`，`B = 13`作为计算样例，我们首先将他们转换为八位二进制数进行表示，分别得到：

```
A = 0011 1100
B = 0000 1101
```

计算后得到：

```
A & B = 0000 1100 // 12
A | B = 0011 1101 // 61
A ^ B = 0011 0001 // -49
```

- **按位取反运算符`~`**

C++中的取反运算符`~`，对单个二进制操作数进行计算，按照每个位进行取反运算，取反规则是`0`变`1`，`1`变`0`。

令变量`A = 60`作为计算样例：

```
A = 0011 1100
~A= 1100 0011 // -61
```

- **左移运算符`<<`**、**右移运算符`>>`**

在C++中，左移运算符`<<`，可以将一个操作数的各二进制位全部左移若干位，得到结果左边多余的二进制位将被丢弃，右边不足的二进制位将被补`0`。

我们对`A = 60`应用左移运算符进行1次位移，可以得到：

```
A = 0011 1100
A << 1 = 0111 1000
```

C++中右移运算符`>>`，可以将一个操作数的各二进制位全部右移若干位，右侧多余的位将会被舍弃，而左侧较为复杂：

- 对于无符号数，会在左侧补`0`；
- 对于有符号数，则会用符号位补齐，正数为`0`，负数为`1`。

我们对`A = 60`应用右移运算符进行`2`次位移，可以得到：

```
A = 0011 1100
A >> 2 = 0000 1111
```



```cpp
#include <iostream>
using namespace std;

int main() {
    int A = 60; // 0011 1100
    int B = 13; // 0000 1101
    
    cout << (A & B) << endl;
    cout << (A | B) << endl;
    cout << (A ^ B) << endl;
    cout << (~A) << endl;
    
    cout << (A << 1) << endl; // 左移1位
    cout << (A >> 2) << endl; // 右移2位
    
    return 0;
}
```



## 练习

```cpp
#include <bits/stdc++.h>
using namespace std; 

int main() {
    // 请补全代码，实现题目功能
    int a,b,c;
    cin >> a >> b >> c;
    cout << ((a|b)&c) << endl;
    return 0;
}

```

