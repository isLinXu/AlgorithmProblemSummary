# 枚举

---

## 引入

定义水仙花数为一个三位数，它的各位数字的立方和等于其本身，比如：$153=1^3+5^3+3^3$。 那我们怎么找到在100到999范围内的水仙花数呢？

> 看完这个题，大家可能一下就想到：我们把这个范围内所有的数检查一遍，输出满足水仙花数条件的数就可以了！
>
> 但是，如果我们手动检查的话，100到999范围内的数字有900个。这样的数据量需要我们颇费一番功夫。
>
> 但是，因为计算机的存在，1秒钟之内可以进行百万千万甚至更多的操作，所以，我们可以通过写一段代码来进行这个过程。
>
> 虽然这个思想很简单，但是在计算机科学中，它仍然是一个算法，叫做**枚举法**。

**枚举法**是利用计算机运算速度快、精确度高的特点，**对要解决问题的所有可能情况，一个不漏地进行检验**，从中找出**符合要求的答案**的方法。

> 虽然枚举法看起来像是一种“笨办法”，但正是因为拥有强大计算能力的计算机的存在，枚举法也变成一种解决问题的有力工具。



## 详细算法描述和代码实现

### **回顾水仙花数**

> 定义水仙花数为一个三位数，它的各位数字的立方和等于其本身，比如：$153=1^3+5^3+3^3$。 现在要求输出所有在100100和999999范围内的水仙花数。

假设我们现在要解决这个问题，最直接的想法就是：

对于所有三位数，检查是否满足水仙花数的条件,如果满足就输出。

现在，我们把算法更严谨地写出来：

1. 枚举100到999之间所有的数。
2. 检查当前的枚举的数字是否满足水仙花数的条件。

> 我们检查水仙花数的条件，其中一种方法就是将枚举到的整数`i`的每一位拆分出来（也叫**十进制拆分**），百位十位个位分别用`a`、`b`、`c`表示，
>
> 然后检查是否满足`a * a * a + b * b * b + c * c * c == i`。
>
> 这就是**枚举法**的思路了。

详细算法描述

- **枚举法**的过程：

> 1. 确定枚举**对象**、枚举**范围**和**判定条件**；
> 2. 枚举可能的解，**验证**是否是问题的解。

引入中水仙花数的例子，对象就是**整数**，范围在**100到999之间**。

假设枚举的数字百位十位和个位分别为a、b、和c，那么判定条件就是：

$$
a^3 + b^3 + c^3 \stackrel{?}{=} a*100+b*10+c
$$
所以，我们用C++中的`for`循环语句来实现这个过程，并用`if`语句来检查判定条件是否成立。

代码实现

**代码框架**

首先，我们给出该算法的整体框架，其中省略了十进制拆分的部分。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n, m;
	for (int i = 100; i <= 999; ++i) {		// 枚举所有100到999的数
        // 十进制拆分
		int a, b, c;
        /* 这里我们省略了十进制拆分的过程 */
		
        // 判断是否满足水仙花数条件
        if (a * a * a + b * b * b + c * c * c == i) {
			printf("%d ", i);
		}
	}
	return 0;
}
```





### 十进制拆分



那么，如何对一个已知有三位的整数进行十进制拆分呢？

- 首先我们考虑如何将个位拆解出来。

> 对于个位，它是一个数字中**整除10剩余的部分**，也就是**模10后的结果**。所以，我们很容易得到求个位的方法：

```c++
c = i % 10;
```

- 那么，我们如何求十位和百位呢？

> 考虑到已经有**求个位的算法**，我们只需要**将十位和百位挪到个位**，然后**使用求个位的方法**，就能分别提取出十位和百位。
>
> 拿十位举例，将十位上的数字移到个位，就相当于将整个数字**整除10**。所以，我们可以得到求十位的方法：

```c++
b = (i / 10) % 10;
```

同样，对于百位：

```c++
a = (i / 100) % 10;
```

这样，我们就对一个三位数进行了十进制拆分。

那么，对于更一般的情况，假设我们要求某数字`x`的第`i`位，怎样做呢？很简单，也是按照与上面一样的流程：

1. 将第`i`位的数字移到个位。
2. 提取个位。

所以，假设我们用`pow_of_10`数组的第`i`位表示10的`i`次方，那么`x`数字的第`i`位可以这样求：

```c++
int ans = (x / pow_of_10[i]) % 10;
```

**完整代码**

这里我们给出水仙花数的完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n, m;
	for (int i = 100; i <= 999; ++i) {		// 枚举所有100到999的数
        // 十进制拆分
		int a = i / 100;		// 拆解i的百位
		int b = i / 10 % 10;	// 拆解i的十位
		int c = i % 10;			// 拆解i的个位
		
        // 判断是否满足水仙花数条件
        if (a * a * a + b * b * b + c * c * c == i) {
			printf("%d ", i);
		}
	}
	return 0;
}
```





## 其他枚举对象举例 

**举例**:

### 统计矩形

给定$n \times m$的网格图，求该网格图有多少长方形（长和宽不等），以及多少正方形。

![img](https://staticcdn.boyuai.com/user-assets/5085/WwQ2PzFvPD8XEg4zufTmqT/%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%A0%BC.jpg!jpg)

### 枚举矩形

要想枚举所有情况的矩形，常见的思路就是枚举**左上角**和**右下角**，或者很多情况只需枚举**左上角**。

**思路**

我们很容易设计下面的算法：

1. 枚举所有矩形，左上角和右下角分别为(i, j)(*i*,*j*)和(k, l)(*k*,*l*)。
2. 检查该矩形是长方形还是正方形，分别累加到对应的计数器里。

下面写出该算法的伪代码

```pseudocode
rec_cnt <- 0
sqr_cnt <- 0
for i <- 1 to n do
    for j <- 1 to m do	// 左上角
        for k <- i to n do
            for l <- j to m do	// 右下角
                if k - i == l - j	// 正方形
                    sqr_cnt <- sqr_cnt + 1
                else
                    rec_cnt <- rec_cnt + 1
输出 rec_cnt 和 sqr_cnt
```

**复杂度**

根据上面的伪代码，一共有4重循环，每次循环只进行了常数个操作，所以整个算法的复杂度是

$T(n) = O(n^4)$

但是上面的算法属于一种“无脑”枚举，其实只要我们稍微加入一些数学计算，就能极大地优化该算法的复杂度。





**举例**: 统计日期

输入两个日期符合格式YYYY年MM月DD日，统计这两个日期之间所有日期所对应的8位数里，有多少3的倍数。

### 枚举日期

要想枚举一年里的所有日期，其不方便的地方或许在于每个月份的天数不一样，而且2月份的天数还会随着闰年平年变化。所以通常的策略是将每个月有多少天存在一个数组里：

```C++
int days[27] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 0号元素无意义
```

这样枚举月份时，日期只需要枚举到该月份所对应数组元素的天数即可。

**思路**

我们可以很容易设计如下算法

1. 枚举两个日期之间的所有日期。
2. 将该日期转化为8位数，并检查是否为3的倍数。

下面我们给出该题的伪代码。

此处需要注意的是，我们需要判断一个年份是否是闰年，从而调整2月份的天数。

```pseudocode
ans <- 0
for y <- Y_1 to Y_2 do		// 枚举两个日期之间的年份，年份差不大于30
    if y是闰年	then days[2] = 29 else days[2] = 28	// 调整2月份的天数
    for m <- 1 to 12 do		// 枚举月份
        for d <- 1 to days[m] do	// 根据月份确定枚举日期范围
            if y年m月d日在Y_1年M_1月D_1日到Y_2年M_2月D_2日之间 then
                num <= y * 10000 + m * 100 + d
                if num % 3 == 0 then
                    ans <- ans + 1
输出 ans
```

这里，因为所有可能的8位数都不会超过10^8108个，所以对于性能比较好的个人笔记本电脑，该算法也肯定能在1s之内跑完。





**举例**: 统计日期

输入两个日期符合格式YYYY年MM月DD日，统计这两个日期之间所有日期所对应的8位数里，有多少3的倍数。

#### 

要想枚举一年里的所有日期，其不方便的地方或许在于每个月份的天数不一样，而且2月份的天数还会随着闰年平年变化。所以通常的策略是将每个月有多少天存在一个数组里：

```C++
int days[27] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 0号元素无意义
```

这样枚举月份时，日期只需要枚举到该月份所对应数组元素的天数即可。

**思路**

我们可以很容易设计如下算法

1. 枚举两个日期之间的所有日期。
2. 将该日期转化为8位数，并检查是否为3的倍数。

下面我们给出该题的伪代码。

此处需要注意的是，我们需要判断一个年份是否是闰年，从而调整2月份的天数。

```pseudocode
ans <- 0
for y <- Y_1 to Y_2 do		// 枚举两个日期之间的年份，年份差不大于30
    if y是闰年	then days[2] = 29 else days[2] = 28	// 调整2月份的天数
    for m <- 1 to 12 do		// 枚举月份
        for d <- 1 to days[m] do	// 根据月份确定枚举日期范围
            if y年m月d日在Y_1年M_1月D_1日到Y_2年M_2月D_2日之间 then
                num <= y * 10000 + m * 100 + d
                if num % 3 == 0 then
                    ans <- ans + 1
输出 ans
```

这里，因为所有可能的8位数都不会超过10^8108个，所以对于性能比较好的个人笔记本电脑，该算法也肯定能在1s之内跑完。





### 枚举区间

要想枚举满足条件的所有区间，最常见的枚举方法就是分别枚举区间的**左右端点**。

**举例**: 序列染色

有连续N个格子。起初每个格子分别被染成了R（红色）G（绿色）B（蓝色）三种不同颜色，问最少改变多少个格子的颜色，使得这N个格子可以被分成R、G、B的三段，且每一段长度不为空。

如下图的例子，第一行的格子通过将第三个涂成红色，第六个涂成蓝色，变成了一行RGB的形式。

![img](https://staticcdn.boyuai.com/user-assets/5085/JECCjRMq8GovvtPxZSMu6Z/RGB.jpg!jpg)

**思路**

因为满足RGB条件的格子染色方案之间，区别在于位于中间的绿色区间的位置。

我们可以设计如下算法：

1. 枚举所有可能的绿色区间的位置[i, j][*i*,*j*]。
2. 计算从原序列到目标序列需要重新涂色的格子个数$Count_{i, j}$。
3. 输出所有$Count_{i, j}$中最小的一个。

在上述思路中，我们枚举的对象是“**绿色区间的位置**”，需要检查的条件是“**需要修改的格子数是否为目前最少的**”。

下面是实现该算法的伪代码：

```pseudocode
ans <- n; 	// 最多修改不会超过n个格子
for i <- 2 to n - 1 do
    for j <- i to n - 1 do
        cnt <- 绿色区间为[i, j]时需要重新涂颜色的格子数
        if cnt < ans then ans <- cnt
输出 ans
```

**复杂度**

因为“`cnt <- 绿色区间为[i, j]时需要重新涂颜色的格子数`”是一个子过程，并且该子过程被运行了$O(n^2)$次，所以，整个算法的复杂度为

T(n) = $O(n^2 \times T(统计需要修改的格子数))$

所以，一个高效的统计方法会降低整个算法的运行时间。目前，我们可以用最简单的方法：

> 将整个序列扫描一遍，如果当前格子的颜色和当前枚举的答案序列不一样，就让统计数值+1。

那么该子过程的复杂度是$O(n)$，而整个算法的复杂度是$O(n^3)$。

后面，我们会介绍用前缀和数组优化该算法的做法。





### 优化

在上面的做法中，我们给出的都是最简单直接的算法。但是当复杂度为$O(n^2)$时，个人电脑在1s之内可能只能处理最多$10^4$的数据规模，而当算法复杂度到$O(n^4)$时，可能数据规模最多只能是$10^2$，所以非常低效。所以，下面我们给出一些**枚举算法的优化思路**：

#### 能算则算

**可以通过必要的计算规避一些不必要的枚举**。

> 比如在上面的**统计矩形**的例子中，我们枚举左上角之后，长方形和正方形满足条件的右下角个数可以通过计算得出。

![img](https://staticcdn.boyuai.com/user-assets/5085/2xS5jp5EgvrLea4cxAmo69/%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%A0%BC2.jpg!jpg)

所以，我们可以通过以下计算来统计$(i, j)$左上角对应对长方形和正方形的贡献

$\text{矩形个数 }= (n - i + 1) * (m - j + 1) \\ \text{正方形个数 }= \min(n - i + 1, m - j + 1) \\ \text{长方形个数 }= \text{ 矩形个数 } - \text{ 正方形个数 }$

#### 能存则存

**可以通过储存更多的信息来避免重复计算**。

> 在上面的**序列染色**的例子中，算法的瓶颈在于对于一个确定的绿颜色区间，如何快速计算需要修改的颜色个数。考虑到该步骤是在询问一个区间上的信息。

**【前缀和优化】**

> - 什么是**前缀**？原数组的第i*i*个前缀指的是第11个到第i*i*个的一段。比如原数组为
>
> (1, 2, 3, 4, 5, 6, 7)
>  则该数组的8个前缀分别为
>
> ```
> 					 	()
> 					    (1)
> 					   (1,2)
> 				      (1,2,3)
> 					 (1,2,3,4)
> 					(1,2,3,4,5)
> 				   (1,2,3,4,5,6)
> 				  (1,2,3,4,5,6,7)
> ```
>
> 
>
> - 什么是**前缀和数组**？仍然假设原数组为
>
> ```C++
> int a[] = {1, 2, 3, 4, 5, 6, 7};
> ```
>
>  那么，对于前缀和数组的第i*i*个元素，它的值就是原数组$1\sim i$这个前缀所有元素的和。所以该数组的前缀和数组为：
>
> ```C++
> int sum[] = {1, 3, 6, 10, 15, 21, 28};
> ```
>
> - **前缀和数组有什么作用**？可以看到，如果我们想求原数组第i*i*个元素到第$j$个元素的和时，只需输出`sum[j] - sum[i - 1]`即可。

使用前缀和数组，区间和可以通过两个前缀和相减快速求出。这里我们可以拓展这个思路，预处理出三个前缀和数组：

```C++
int a[N];		// 原序列

int not_R[N];	// 前i个格子里不是红色的格子个数
int not_G[N];	// 前i个格子里不是绿色的格子个数
int not_B[N];	// 前i个格子里不是蓝色的格子个数

for (int i = 1; i <= n; ++i) {
    not_R[i] = not_R[i - 1] + (a[i] != 'R');
    not_G[i] = not_G[i - 1] + (a[i] != 'G');
    not_B[i] = not_B[i - 1] + (a[i] != 'B');
}
```

这样，对于一个绿色区间[i, j][*i*,*j*]，总需要修改的格子数为三个颜色区间里，不等于各自颜色的格子数量求和：

```C++
n_change = not_R[i - 1] + (not_G[j] - not_G[i - 1]) + (not_B[n] - not_B[j]);
```



## 总结

- 枚举法是一种通过**枚举所有可能解**，**检查该可能解是否符合要求**，**并将符合要求的解计入答案的方法**。
- 在解决问题的过程中，我们需要枚举的对象有很多种，比如数值、区间、矩形、日期等等。
- 在设计枚举算法时，一些思路直接的算法虽然很容易理解，但是通常会导致高昂的时间代价。所以我们可以通过**加入数学计算**、并且**存储尽可能多的信息**的方法，来降低时间复杂度。
- 严谨描述一下**枚举法**的过程：

> 1. 确定枚举**对象**、枚举**范围**和**判定条件**；
> 2. 枚举可能的解，**验证**是否是问题的解。

 

**枚举示例**

比如引入中水仙花数的例子，对象就是**整数**，范围在**100到999之间**。假设枚举的数字百位十位和个位分别为a、b、和c，那么判定条件就是：
$$
a^3 + b^3 + c^3 \stackrel{?}{=} a*100+b*10+c
$$
所以，我们用C++中的`for`循环语句来实现这个过程，并用`if`语句来检查判定条件是否成立。

**代码框架**

首先，我们给出该算法的整体框架，其中省略了十进制拆分的部分。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    for (int i = 100; i <= 999; ++i) {    // 枚举所有100到999的数
        // 十进制拆分
        int a, b, c;
        /* 这里我们省略了十进制拆分的过程 */
		
        // 判断是否满足水仙花数条件
        if (a * a * a + b * b * b + c * c * c == i) {
            printf("%d ", i);
        }
    }
    return 0;
}
```

**完整代码**

这里我们给出水仙花数的完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n, m;
	for (int i = 100; i <= 999; ++i) {    // 枚举所有100到999的数
        // 十进制拆分
        int a = i / 100;        // 拆解i的百位
        int b = i / 10 % 10;    // 拆解i的十位
        int c = i % 10;         // 拆解i的个位
		
        // 判断是否满足水仙花数条件
        if (a * a * a + b * b * b + c * c * c == i) {
            printf("%d ", i);
        }
    }
    return 0;
}
```



### 纸币支付方案

小明钱包里装着各种纸币。纸币有4种（纸币的类型有1元、3元、5元和10元），每一种分别有a、b、c、d张。现在小明要出门买东西，他需要支付N元，在不找零的情况下，请问能支付成功吗？如果能成功支付，那么请计算出有多少种支付方式；如果不能成功支付，就输出no。

输入描述：

输入共 1 行，包含 5个整数 a、b、c、d、n，之间用一个空格隔开。abcd小于11

输出描述：

如果不能成功支付，则输出：no

如果可以成功支付，则输出：一个整数，表示支付方式的总数

示例 1：

输入：

```
1 1 1 1 1
```

输出：

```
1
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int main() {
    // 请补全代码，实现题目功能
    // 1,3,5,10的张数，以及总价，枚举时的支付价，支付方式数量
    int a, b, c, d, n, sum, num=0;
    cin >> a >> b >> c >> d >> n;

    for (int i=0; i<=d; i++) {
        if (i*10 > n)
            break;
        for (int j=0; j<=c; j++) {
            if ((i*10 + j*5) > n)
                break;
            for (int k=0; k<=b; k++) {
                if ((i*10 + j*5 + k*3) > n)
                    break;
                for (int p=0; p<=a; p++) {
                    sum = i*10 + j*5 + k*3 + p;
                    if (sum == n)
                        num += 1;
                    else if (sum > n)
                        break;
                }
            }
        }
    }

    if (num)
        cout << num << endl;
    else
        cout << "no" << endl;
    return 0;
}

```







### [SC01] 水仙花数

春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的： “水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=13+53+33。现在要求输出所有在𝑚和𝑛范围内的水仙花数。

输入描述：

每个样例输入数据一行，包括两个整数𝑚和𝑛（100≤𝑚≤𝑛≤999）。

输出描述：

对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于𝑚,并且小于等于𝑛，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;

如果给定的范围内不存在水仙花数，则输出𝑛𝑜;

每个测试实例的输出占一行。

示例 1：

输入：

```
100 120
```

输出：

```
no
```

示例 2：

输入：

```
300 380
```

输出：

```
370 371
```


实现

```

```


