# 子集枚举

---

## 引入

**子集枚举**，顾名思义就是在枚举所有子集。为了解释这句话，我们需要先明确几个概念：

- **集合**: 集合就是**包含一些对象的整体**。

> 比如一个学校里，“全体同学”就是包含所有同学的集合；“全体男生”就是包含所有男同学的集合，“全体女生”就是包含所有女同学的集合。

- **子集**: 子集就是**只包含**某集合中**一部分对象的集合**。

> 比如在学校中的“全体同学”里，“经管系的同学”就是“全体同学”的一个子集。另外，每个非空集合都有两个最特殊的子集。一个是**空集**，不包含该集合中的任何元素。另一个是**该集合本身**，包含该集合中的所有元素。

了解了集合和子集的概念以后，我们来看一个例题：

**【举例】**

假设我们有个集合$\{1, 2, 3, \ldots, n\}$，输出所有满足集合中所有数求和是3的倍数的子集的个数。

**【思路】**

回顾一下**枚举的基本思想**：

> 1. 确定枚举**对象**、枚举**范围**和**判定条件**；
> 2. 枚举可能的解，**验证**是否是问题的解。

我们也可以用这个思路解决该问题，那么该题的算法就是：

- 步骤1：枚举所有子集S*S*。
- 步骤2：如果枚举到的子集S*S*满足条件，则将其计入答案。

对于步骤2，算法设计是比较直接的。给定集合S*S*，要想检查它是否满足“所有数求和是3的倍数”这个条件，只需要将所有的数加起来，模3，检查结果是否为0即可。

但是对于步骤1，我们如何枚举一个集合的所有子集呢？这就要涉及到我们的**子集枚举**算法。





## 子集的表示方式

首先，我们需要**明确子集在计算机中的表示方式**。并且，如果想让计算机高效地枚举一个对象，我们需要一个能利于计算机这样做的表示方式。

### 数组表示法

最直接能够想到的一种表示方式（或存储方式），就是**数组**。因为对于原来集合是$\{1, 2, 3, 4, 5, 6\}$，我们通常会按照如下形式存储：

```C++
int a[10] = {1, 2, 3, 4, 5, 6};
int n = 6;  // 表示集合的大小
```

这样，如果我们存储子集时，可以用同样的方法：

```c++
int a_1[10] = {1, 2};      // a_1表示的是子集{1, 2}
int n_1 = 2;               // a_1子集的元素个数
int a_2[10] = {3, 5, 6};   // a_2表示的是子集{3, 5, 6}
int n_2 = 3;               // a_2子集的元素个数
int a_3[10] = {1};         // a_3表示的是子集{1}
int n_3 = 1;               // a_3子集的元素个数
```

上面的代码显示了原集合中的三个子集。

但是目前为止，我们可能想不到什么好方法去枚举它。那么，子集有什么其他表示方法吗？



### 01比特串法

另一种表示子集的方式就是**01比特串**。什么是01比特串？

我们可以类比“字符串”，而将“比特串”类比为一串01数字。我们通过如下方式用长度为n的01比特串表示一个大小为n的集$合\{a_1, \ldots, a_n\}$的子集：

> 如果01比特串的第`i`个元素是0，表示在该子集中没有包含第`i`个元素，相反如果第`i`个元素是1，则表示该子集中包含了第`i`个元素。

**举例**

对于集合\{1, 2, 3, 4, 5, 6\}

> - `010001`表示子集\{2, 6\}。
> - \{1, 2, 3, 5}表示成`111010`。

我们选择**01比特串法**，是因为**它是一种对枚举很友好的表示方法**。

> 对于一个大小为n的集合，它的所有子集对应着所有`00...0`到`11...1`的长度为n的比特串。
>
> 而长度为n的比特串又对应着范围从00到$2^n-1$的整数。
>
> 所以，如果我们想枚举所有子集的话，就是在枚举该子集的比特串表示，就是在枚举该比特串的整数。

下面，我们先解决两个比较关键的问题，然后再给出完整代码：

1. **枚举整数的范围**：从0（空集）枚举到$2^n - 1$（也就是原集合本身）

> 因为对我们有用的只有长度为n的01比特串，超过n以后就没有意义了。所以如果转化成整数的话，最大的n位二进制整数是$2^n - 1$。所以枚举整数的时候，应该从0（空集）枚举到$2^n - 1$（也就是原集合本身）。

1. **如何知道第`i`个元素是否在集合里**。

> 因为我们在枚举的时候枚举的是整数而不是直接枚举01比特串。所以怎样知道一个整数`num`在二进制表示下第`i`位是0还是1呢？（这里第`i`位为从最低位开始数的第`i`位）

这里我们用一些**位运算**的技巧。

首先考虑一个比较简单的问题：怎样知道最低位是0还是1呢？我们只需要计算`num & 1`即可（`&`为与操作），根据一个例子感受一下这么做的原因：

$101011 \text{ \& } 1 = 101011 \text{ \& 000001} = 000001 = 1$

$101010 \text{ \& } 1 = 101010 \text{ \& 000001} = 000000 = 0$

另外，**`num & 1`也可用于检查数字`num`的奇偶性**。

> 这是因为当数字`num`是奇数时，二进制表示下的最低位就是1，而如果它是偶数，那么二进制表示下最低位就是0。
>
> 所以检查奇偶性和检查二进制位最低位是等价的。

现在我们知道如何检查最低位，也就是第1位了。那么如果想检查第2位怎么办呢？

我们可以想办法把**“检查第2位”转换成“检查第1位”这个问题**。具体转换方法，就是将整个二进制数字，**向右平移一位**。

> - 对于向右平移一位，位运算中有对应的**右移运算符`>>`**;
> - 右移运算符在计算结果上，相当于“除以2下取整”;
> - 在视觉效果上，就相当于将二进制表示下的数字丢掉最低位，并向右移一位;
> - 这里，我们可以拿十进制做类比：在十进制下，“除以10下取整“就相当于在十进制下去掉最低位，向右平移1位，例如：

$$
\lfloor 12345 \div 10\rfloor = 1234
$$

所以，检查`num`的第2位就相当于，先将数字向右平移1位，再检查最低位，代码写出来就是：

```c++
int second_bit = (num >> 1) & 1;
```

由第2位类比任意第`i`位，我们可以得到如下代码。假如我们要枚举长度为`n`的01比特串的每一位，如果习惯从`1`枚举到`n`的话，可以用上面一行；如果习惯从`0`枚举到`n-1`，可以用下面一行。

```c++
int i_th_bit = (num >> (i - 1)) & 1;    // 如果i的范围是1到n
int i_th_bit = (num >> i) & 1;          // 如果i的范围是0到n-1
```



代码实现 —— 集合中所有数求和是3的倍数的子集的个数

回顾引入的部分给出的例子

> 假设我们有个集合\{1, 2, 3, \ldots, n\}{1,2,3,…,*n*}，输出所有满足集合中所有数求和是3的倍数的子集的个数。

可以用如下代码实现。

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
int main() {
    scanf("%d", &n);    // 集合大小，也就是01比特串的长度
    int tot = 1 << n;   // 枚举数字代替01比特串，范围为0到2^n - 1
    int ans = 0;
    for (int num = 0; num < tot; ++num) {  // 枚举每个代表01比特串的数字
        long long sum = 0;
        for (int i = 0; i < n; ++i)        // 枚举01比特串的每一位
            if ((num >> i) & 1) {          // 检查第j位是否为1，注意这里是从0开始枚举
                sum += (i + 1);            // 如果该位是1，就把对应的数字加到求和的变量里
            }
        if (sum % 3 == 0) ++ans;           // 如果满足题目要求（3的倍数），计入答案
    }
    printf("%d\n", ans);
}
```





### 递归枚举子集

之前我们给出了用**数组**表示集合的方法。那么有没有一种枚举方式可以基于这种表示方法来枚举集合的所有子集呢？

答案是有的，在以后学习递归的过程中，我们可以写一个递归函数，生成表示每个子集的对应数组。

这里我们简单提一下，其本质思想就是**分情况讨论**：

![img](https://staticcdn.boyuai.com/user-assets/5085/waybMJa6mb5wu1s6CxM597/%E9%80%92%E5%BD%92%E6%A0%91.png!png)

在这个结构中，第`i`层的结点表示的是基于上面的结点对应的子集再加入一个元素的可能情况。

所以，我们就按照这个树形结构枚举了所有的子集。

以在实现上，我们需要用一种叫做“**递归**”的方式将这个树形结构在代码中生成出来。

使用这种基于**数组**表示法和**递归**方法枚举子集的好处，是因为它的复杂度是$O(2^n)$，**要好于01比特串的枚举方法**。



在本知识点，我们解决了如何枚举子集的问题，包括：

- 如何表示子集：用01比特串表示。
- 如何枚举子集：将01比特串与其表示的整数等价，转化为简单的枚举整数的问题。
- 如何提取第`i`个元素是否存在于子集的信息：位运算，具体思路为将第`i`位右移至第1位，转换为检查第1位的问题。检查第1位，可以将原数字与`1`取与运算得到。



## [NOIP2014普及组] 珠心算测验

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。

某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？

最近老师出了一些测验题，请你帮忙求出答案。

输入描述：

共两行，第一行包含一个整数𝑛，表示测试题中给出的正整数个数。

第二行有𝑛个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。

输出描述：

一个整数，表示测验题答案。

示例 1：

输入：

```
4
1 2 3 4
```

输出：

```
2
```



实现

```cpp
#include <bits/stdc++.h>
#define N 105 
using namespace std; 
 
int a[N], n; 


bool check(int i) { 
        for (int j = 0; j < n; ++j) 
            for (int k = j + 1; k < n; ++k) 
                if (a[j] + a[k] == a[i]) return true; 
    return false; 

} 

int main() { 
    scanf("%d", &n); 
    for (int i = 0; i < n; ++i)  
        scanf("%d", &a[i]); 

    int sum = 0; 
    for (int i = 0; i < n; ++i) 
        if (check(i)) ++sum; // 也可以是 sum += check(i)

    printf("%d\n", sum); 
        return 0; 
    
    return 0; 
}

```





