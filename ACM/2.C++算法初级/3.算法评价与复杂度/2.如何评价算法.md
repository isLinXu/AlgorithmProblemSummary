# 如何评价算法

---

## 引入

之前我们提到，之所以要评价算法，有两方面原因。

- 一方面，**是因为算法所需要解决问题的结果具有时效性**。比如战争时期的密码破译算法，其破解出来的明文，作为重要的军事情报只有在该事件未发生时才是有价值的。
- 另一方面，**是因为用于运行算法的机器其计算资源是有限的**。如个人笔记本电脑，现在比较常见的就是1秒钟进行最多$2\times 10^9$次计算，以及16G内存。

> 而通常，就像通往罗马的路不止一条一样，能解决某个问题的算法也有很多，所以，具体选择哪个算法来解决问题，我们需要一个可供参考的评价指标。

**举例**：

给定一个长度为n的数组，接下来是程序要回答的m*m*个问题（也叫m*m*组询问），每个问题要求程序输出从第i*i*个元素到第j*j*个元素($1 \leq i \leq j \leq n$)的和是多少。

- **第一种方法**：对于每组询问，手动加一遍。

  ```C++
  #include <bits/stdc++.h>
  using namespace std;
  int n, a[100005];
  int m;
  int main() {
      // 读入长度为n的数组
      cin >> n;
      for (int i = 1; i <= n; ++i) cin >> a[i];
      
      // 读入m组询问并求解
      cin >> m;
      for (int i = 1; i <= m; ++i) {
          // 读入询问
          int x, y;
          cin >> x >> y;
          
          // 求解答案
          long long ans = 0;
          for (int j = x; j <= y; ++j) ans += a[j];
          cout << ans << endl;
      }
      return 0;
  }
  ```

- **第二种方法**：预处理前缀和数组。

- **前缀**: 原数组的第i*i*个前缀指的是第11个到第i*i*个的一段。

> 比如原数组为
>
> (1, 2, 3, 4, 5, 6, 7)(1,2,3,4,5,6,7)
>
> - 则该数组的8个前缀分别为
>
> ```
> 						()
> 					   (1)
> 					  (1,2)
> 					 (1,2,3)
> 					(1,2,3,4)
> 				   (1,2,3,4,5)
> 				  (1,2,3,4,5,6)
> 			     (1,2,3,4,5,6,7)
> ```

- 什么是**前缀和数组**？

> 仍然假设原数组为
>
> ```C++
> int a[] = {1, 2, 3, 4, 5, 6, 7};
> ```
>
> 那么，对于前缀和数组的第i*i*个元素，它的值就是原数组1\sim i1∼*i*这个前缀所有元素的和。所以该数组的前缀和数组为：
>
> ```C++
> int sum[] = {1, 3, 6, 10, 15, 21, 28};
> ```

- **前缀和数组有什么作用**？

  可以看到，如果我们想求原数组第i*i*个元素到第j*j*个元素的和时，只需输出`sum[j] - sum[i - 1]`即可。

回到本题，因为原数组元素从未改变，所以它的前缀和数组也不会改变。那我们可以得出下述算法：

1. 预处理原数组的前缀和数组`sum`。
2. 对于每个询问`x, y`，输出`sum[y] - sum[x - 1]`。

该算法实现如下：

```c++
#include <bits/stdc++.h>
using namespace std;
int n, a[100005]， sum[100005];
int m;
int main() {
    // 读入长度为n的数组
    cin >> n;
    sum[0] = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        // 预处理前缀和数组。
        sum[i] = sum[i - 1] + a[i];
    }
    
    // 读入m组询问并求解
    cin >> m;
    for (int i = 1; i <= m; ++i) {
        // 读入询问
        int x, y;
        cin >> x >> y;
        
        // 求解答案
        cout << sum[y] - sum[x - 1] << endl;
    }
    return 0;
}
```

可以看到，上面两种算法的区别主要有两点：

1. “求解答案”处，第一种做法使用了`for`循环，第二种做法没有。
2. 第二种做法比第一种做法多定义了`sum`数组。

所以，我们大致能感觉到，第一种做法用过`for`循环之后步骤更多，**时间**会更久；

第二种做法需要更多的**内存空间**来定义额外的`sum`数组。



## 时间复杂度

现在，我们分别讨论两个评估算法的指标，**时间复杂度**和**空间复杂度**。

### 最坏情况下时间复杂度

**时间复杂度**描述的是**算法运行时间和输入规模的关系**。

它基于以下设定：

- **每条语句运行都需要消耗一定时间**;

> 所以程序的运行时间，和语句的数量有关。

- **运行时需要执行的语句条数和输入的规模相关**。

> 而且通常情况下，输入规模越大，语句越多（一般不会不变因为读入语句的数量就会随着输入规模增长而增长）。如上一节的例子： 数组越长，`for`循环读入和计算前缀和需要枚举的范围就越长，所以需要运行的计算前缀和的语句条数就越多。

```c++
cin >> n;
for (int i = 1; i <= n; ++i) {
    cin >> a[i];
}
```

由这两条可以得出结论：

- **算法的运行时间**是**关于输入规模**的一个**函数**。
- 这个函数被称为该算法的**时间复杂度**。这里我们用n*n*表示输入规模，用T(n)*T*(*n*)表示算法的运行时间。

但从上一节例子的第一种做法中，我们会发现算法的运行时间不仅和输入规模（也就是数组长度和询问个数）有关，还与具体的询问内容有关。

> 例如,如果每次询问的区间[x, y][*x*,*y*]都满足x = y，算法的运行时间肯定比每次都满足x=1, y=n要快。我们如何将这种情况考虑进算法的时间评估中呢？

所以，我们评估算法的运行时间，一个很常用的指标是**最坏时间复杂度**。

- **最坏时间复杂度**描述的是在**规模为n的所有可能的输入中**，**最坏情况下**算法的运行时间。

> 之所以这样做，是因为算法设计的目的是为了解决一类问题，而如果更明确地阐述清楚“解决”的意思，就是在一定的限制条件下（包括时间和空间），对于所有这类问题的具体实例该算法都可以输出正确结果。所以，我们只需要评估该算法在这类问题中“最难的实例”解决问题的时间，并且保证该时间不超过合理的范围内即可。



## 大O记号

另外，我们还可以得出一个结论：

- **算法的运行时间可以用算法运行的语句数量近似表示**。

> 也就是说，我们可以将T(n)定义成算法运行的**语句条数**。那么对于下面一段代码：

```C++
cin >> m;
for (int i = 1; i <= m; ++i) {
    // 读入询问
    int x, y;
    cin >> x >> y;

    // 求解答案
    cout << sum[y] - sum[x - 1] << endl;
}
```

算法的语句条数为：

> 1 (`cin >> m`)
>
> \+ 1 (`int i = 1`)
>
> \+ m + 1 (`i <= m` 对于`i`从1到m+1各比较一次)
>
> \+ m(`++i`对于i从1到m各运行一次)
>
> \+ m (`int x, y;`对于i从1到m各运行一次)
>
> \+ m (`cin >> x >> y;`对于i从1到m各运行一次)
>
> \+ m (`cout << sum[y] - sum[x - 1] << endl`对于`i`从1到m各运行一次)
>
> =5m+3

可以发现，这样的计算是十分繁琐的。可在实际的算法评估中，这样细节的计算是很没有意义有的，这是因为以下两点：

- 代码的运行时间受**语句种**和**运行环境**的影响。

> 即便对于一条效果相同的语句，不同的实现方式运行的时间也不一样。
>
> 参考：https://stackoverflow.com/questions/15596318/is-it-better-to-avoid-using-the-mod-operator-when-possible

> 另外，即便是同一段代码，用不同的编译器编译成可执行程序，放在不同架构的处理器下运行，其运行时间也都是不一样的。
>
> 比如在用命令行编译C++程序时，可以加入`-march=native`参数，会令编译器自动探测编译所在主机，并且针对该目标架构进行特定的优化，使得代码可以运行得更快。

- 代码效率评估**只关心数据规模大时的代码效率**。

> 因为我们使用计算机解决问题的场景主要是针对人力所不能及的数据规模，这样才能发挥计算机更加强大的计算能力。
>
> 所以，根据上面的例子，如果数据规模很小（`m=1`）时，可能最后额外的`+3`就占了所有语句3/83/8的比例。相反，如果数据规模很大（`m=100000`），那么式子中多出来的3条语句就只占所有语句的3/5000003/500000，就是微不足道的。

#### 

由于上面列举的原因，我们统一一种估算方式。我们用以下几个例子先感受一下（其中n表示输入数据规模）：

|      | 估算前            | 估算后   |
| ---- | ----------------- | -------- |
| 1    | $100$             | $O(1)$   |
| 2    | $5n^3 + 7n^2 + 3$ | $O(n^3)$ |
| 3    | $3\cdot 2^n$      | $O(2^n)$ |

- 可以看到，我们在估算算法效率时只保留**增长最快的一项除了系数以外的部分**，相当于只保留了该式子的“**数量级**”。

当然，在实际场景中，我们也会针对算法的某个部分分析其效率。

> 特别的，如果一个算法某个部分的运行时间并不随着输入规模的增长而增长，那我们称其的复杂度为**常数**。



## 时间复杂度举例

- $O(1)$——常数条语句：交换两个元素

  ```C++
  // 输入
  int a = 4;
  int b = 6;
  
  // 计算
  int t = a;
  a = b;
  b = t;
  ```

- $O(n)$——单重循环求数组和

  ```C++
  // 输入
  int a[] = {2, 0, 1, 3, 5};
  int n = 5;
  
  int sum = 0;
  for (int i = 0; i < n; ++i) sum += a[i];
  ```

- $O(n^2)$——双重循环求数组中相等元素对数

  ```C++
  // 输入
  int a[] = {1, 1, 3, 5, 5};
  int n = 5;
  
  // 计算
  int cnt = 0;
  for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
          cnt += (a[i] == a[j]);
  ```

- $O(2^nn)$——枚举n个数字组成集合的所有子集，输出子集和。

  ```C++
  // 输入
  int a[] = {2, 1, 3, 6, 5};
  int n = 5;
  
  // 计算
  int tot = 1 << 5;	// 相当于求2的5次方
  for (int i = 0; i < tot; ++i) {
       // 变量i的二进制形式用于表示每个元素选（1）与不选（0）。
      int sum = 0;
      for (int j = 0; j < n; ++j)
          if ((i >> j) & 1) sum += a[j];	// 检查i的第j位是否是1
      cout << sum << endl;
  }
  ```
  
  
  
  ## 空间复杂度
  
  同样，我们也可以将**程序所消耗空间的大小**表示成一个**与输入规模有关的函数**，该函数称为**空间复杂度**。
  
  > 但空间复杂度情况数比时间复杂度少，常见的场景就是估算数组大小：
  
  ```C++
  // 假设数据规模最大为N
  int a;       // 常数空间复杂度
  int a[N];    // 此时空间复杂度为 O(N)
  int a[N][N]; // 此时空间复杂度为 O(N^2)
  ```



## 总结

算法运行环境是一个物理的机器，**该机器的计算能力和存储空间都是有限的**。所以，对于一个算法能不能在有限资源下成功输出结果，我们需要对其时间和空间进行评估。

### 时间复杂度：

- 时间复杂度通常是该算法**在用最坏情况下的时间复杂度**，使用**大O记号**用来表示估算的结果。

**举例**：

- O(1)——常数条语句：交换两个元素

  ```C++
  // 输入
  int a = 4;
  int b = 6;
  
  // 计算
  int t = a;
  a = b;
  b = t;
  ```

- $O(n)$——单重循环求数组和

```C++
// 输入
int a[] = {2, 0, 1, 3, 5};
int n = 5;

int sum = 0;
for (int i = 0; i < n; ++i) sum += a[i];
```

- $O(n^2)$——双重循环求数组中相等元素对数

```C++
// 输入
int a[] = {1, 1, 3, 5, 5};
int n = 5;

// 计算
int cnt = 0;
for (int i = 0; i < n; ++i)
    for (int j = i + 1; j < n; ++j)
        cnt += (a[i] == a[j]);
```

- $O(2^n)$——枚举n个数字组成集合的所有子集，输出子集和。

```C++
// 输入
int a[] = {2, 1, 3, 6, 5};
int n = 5;

// 计算
int tot = 1 << 5;	// 相当于求2的5次方
for (int i = 0; i < tot; ++i) {
     // 变量i的二进制形式用于表示每个元素选（1）与不选（0）。
    int sum = 0;
    for (int j = 0; j < n; ++j)
        if ((i >> j) & 1) sum += a[j];	// 检查i的第j位是否是1
    cout << sum << endl;
}
```

### 空间复杂度：

**举例**：

```C++
// 假设数据规模最大为N
int a;       // 常数空间复杂度
int a[N];    // 此时空间复杂度为 O(N)
int a[N][N]; // 此时空间复杂度为 O(N^2)
```



