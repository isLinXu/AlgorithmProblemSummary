# 递推

---

## 递推思想简介

**递推**，意思就是用已经有的信息一点点推出想要知道的信息。

> 比如，平面上有一个机器人，一开始在坐标`(0,0)`处，第一秒向东移动一米，第二秒向南移动两米，第三秒向西移动三米，第四秒向北移动四米……机器人一直按照这个规律移动下去。由于我们知道了最开始的时候机器人的位置，我们就可以一秒一秒地推算出接下来每一个时刻机器人的位置。这就是递推。

显然，如果我们用人脑去模拟一个**递推**算法，是比较简单的，因为“**根据已有信息推出未知信息**”是我们常用的思考方式，符合直觉。

如果用电脑运行**递推**算法，我们应该考虑使用循环。我们可以在循环的过程中使用数组和临时变量记录下来每一步递推的过程和结果。比如在刚刚的机器人例子中，我们可以使用数组来记录每一秒结束时机器人的具体位置，使用临时变量来记录机器人当前的朝向。这和我们使用人脑模拟递推算法的区别不大。



## **张爽的青蛙**

> 地上有n个石头从左到右排成一排，张爽同学养的青蛙要从第一个石头跳到最后一个石头上，每次可以选择向右跳一格或者跳两格，问总共有多少种不同的走法？ 答案对998244353取模。

比如，如果青蛙要从第一个石头跳到第五个石头，有以下五种可能的走法：

- 1->2->3->4->5
- 1->2->3->5
- 1->2->4->5
- 1->3->4->5
- 1->3->5

**张爽的青蛙**问题其实就是[斐波那契数列](https://baike.baidu.com/item/斐波那契数列/99145?fr=aladdin)的一种变形。

要使用**递推**解决这个问题，我们需要先对这个问题进行数学建模，找出**递推式**。

我们开一个数组`int f[n]`，其中`f[i]`表示从第一个石头跳到第`i`个石头一共有多少种方案（对998244353取模）。

接下来，我们尝试寻找递推关系：如果我们知道了`f[1], f[2], f[3], ..., f[k-1]`的取值，那么`f[k]`应该是多少呢？





f[k]的值是多少呢？

> **张爽的青蛙**
>
> 地上有n*n*个石头从左到右排成一排，张爽同学养的青蛙要从第一个石头跳到最后一个石头上，每次可以选择向右跳一格或者跳两格，问总共有多少种不同的走法？ 答案对998244353取模。

**对张爽的青蛙问题进行建模**

`f[k]`的值是多少呢？首先，最后一步肯定会落在`k`上，我们不妨把所有从`1`走到`k`的路径分成两类：一种路径是最后一步跳了一个石头，另外一种是最后一步跳了两个石头。

最后一步跳了一个石头：

- 1->2->3->4->5
- 1->2->4->5
- 1->3->4->5

最后一步跳了两个石头：

- 1->2->3->5
- 1->3->5

再抽象一点，这两类路径是：

- 先从`1`走到`k-1`，再走一步到`k`
- 先从`1`走到`k-2`，再一次走两个石头到`k`

而从`1`走到`k-1`的方案数是`f[k-1]`，从`1`走到`k-2`的方案数是`f[k-2]`，所以我们有：

- 先从`1`走到`k-1`，再走一步到`k`，有`f[k-1]`种方法
- 先从`1`走到`k-2`，再一次走两个石头到`k`，有`f[k-2]`种方法

所以从`1`走到`k`的方案数就是`f[k] = f[k-1] + f[k-2]`，这就是我们需要的递推式。

同时，我们知道`f[1] = f[2] = 1`，因为从`1`走到`1`只有一种方案（呆在原地不动），从`1`走到`2`也只有一种方案（走一格）。这便是**递推的初始条件**。

接下来，就是把**初始条件**和**递推式**写成循环，得到结果：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353; // 答案对998244353取模。
int k, f[1000010];

int main() {
    cin >> k;
    f[1] = f[2] = 1; // 初始条件
    for( int i = 3; i <= k; ++i )
        f[i] = (f[i-1] + f[i-2]) % MOD; // 递推式，记得取模
    cout << f[k] << endl;
    return 0;
}
```


我们再回顾一下**算法描述**：

从第`1`步走到第`k-1`步的方案数是`f[k-1]`，从`1`走到`k-2`的方案数是`f[k-2]`，所以我们有：

- 先从`1`走到`k-1`，再走一步到`k`，有`f[k-1]`种方法
- 先从`1`走到`k-2`，再一次走两个石头到`k`，有`f[k-2]`种方法

所以从`1`走到`k`的方案数就是`f[k] = f[k-1] + f[k-2]`，这就是我们需要的**递推式**。

同时，我们知道`f[1] = f[2] = 1`，因为从`1`走到`1`只有一种方案（呆在原地不动），从`1`走到`2`也只有一种方案（走一格）。这便是递推的**初始条件**。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int k = 10; // 要计算第几步
int f[1000010];

int main() {
    f[1] = f[2] = 1; // 初始条件
    for( int i = 3; i <= k; ++i )
        // TODO 请补全下述代码
        f[i] = (f[i-1] + f[i-2]) % MOD; // 请补全递推式，记得取模
    cout << f[k] << endl;
    return 0;
}
```



## 卡特兰数

让我们再来看一个有趣的问题，**卡特兰数**：

> 由n对括号组成的括号序列，有多少种是合法的括号序列？答案对998244353取模。
>
> 什么是合法的括号序列？其定义如下：
>
> - 空序列是合法的括号序列
> - 如果A是合法的括号序列，那么(A)是合法的括号序列
> - 如果A和B是合法的括号序列，那么AB也是合法的括号序列

简单通俗地讲，合法的括号序列就是：任何一个左括号都必须有与之对应的右括号，任何一个右括号都必须有与之对应的左括号。

比如：

- `()(()(()))`是合法的括号序列
- `)(`不是合法的括号序列，因为第一个右括号没有与之对应的左括号
- `(()))`不是合法的括号序列，因为最后一个右括号没有与之对应的左括号

类似的，如果我们想用递推解决问题，我们就要找到递推式。首先开一个数组`int f[n]`，用`f[i]`来表示`i`对括号能够组成多少种合法的括号序列。那么，怎么根据`f[0], f[1], f[2], ..., f[k-1]`的值推出`f[k]`的值呢？(请你先想想看~)

### 对卡特兰数进行建模

**卡特兰数**：

> 由n对括号组成的括号序列，有多少种是合法的括号序列？答案对998244353取模。
>
> 什么是合法的括号序列？其定义如下：
>
> - 空序列是合法的括号序列
> - 如果A是合法的括号序列，那么(A)是合法的括号序列
> - 如果A和B是合法的括号序列，那么AB也是合法的括号序列

我们继续使用分类讨论的思想：由于合法括号序列的最后一个字符一定是右括号，不妨假设最终的括号序列长成这个样子：`A(B)`。其中，A和B都是合法括号序列（注意A和B可以是空序列）。

我们把最终的序列分成`k`种：

- `A`由`0`对括号组成，`B`由`k-1`对括号组成，这样的序列有`f[0] * f[k-1]`种
- `A`由`1`对括号组成，`B`由`k-2`对括号组成，这样的序列有`f[1] * f[k-2]`种
- `A`由`2`对括号组成，`B`由`k-3`对括号组成，这样的序列有`f[2] * f[k-3]`种
- ……
- `A`由`m`对括号组成，`B`由`k-1-m`对括号组成，这样的序列有`f[m] * f[k-1-m]`种
- ……
- `A`由`k-1`对括号组成，`B`由`0`对括号组成，这样的序列有`f[k-1] * f[0]`种

于是我们就得到了**递推式**：
$$
f(n) = \sum_{k=0}^{n-1} f(k) \times f(n-k-1)
$$
同样，**初始条件**是`f[0] = 1`，因为`0`对括号只能组成一种括号序列（空序列）。

至此，代码呼之欲出：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
int n, f[100010];

int main() {
    cin >> n;
    f[0] = 1; // 初始条件
    for( int i = 1; i <= n; ++i ) { // 求f[i]的值
        for( int k = 0; k < i; ++k ) {
            f[i] += int((long long)f[k] * f[i-k-1] % MOD); // 递推式
            // 注意，两个int相乘的结果可能爆int，因此乘法的过程要转换成long long以避免整数溢出
            f[i] %= MOD; // 记得取模
        }
    }
    cout << f[n] << endl;
    return 0;
}
```

容易发现，该算法核心递推式的执行次数是：`1 + 2 + 3 + ... + n`，因此**算法复杂度**是`O(n^2)`。



## 总结

- **递推**思想：

  根据已有的东西一点点地推出未知的东西。

- 使用递推解题三步骤：

  - 数学建模
  - 找出递推式和初始条件
  - 写出代码。

- **张爽的青蛙（斐波那契）问题**：地上有n*n*个石头从左到右排成一排，张爽同学养的青蛙要从第一个石头跳到最后一个石头上，每次可以选择向右跳一格或者跳两格，问总共有多少种不同的走法？

  - 递推式：`f[n] = f[n-1] + f[n-2]`；
  - 初始条件：`f[1] = f[2] = 1`。因为从`1`走到`1`只有一种方案（呆在原地不动），从`1`走到`2`也只有一种方案（走一格）；
  - 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353; // 答案对998244353取模。
int k, f[1000010];

int main() {
    cin >> k;
    f[1] = f[2] = 1; // 初始条件
    for( int i = 3; i <= k; ++i )
        f[i] = (f[i-1] + f[i-2]) % MOD; // 递推式，记得取模
    cout << f[k] << endl;
    return 0;
}
```

- **卡特兰数问题**：由n*n*对括号组成的括号序列，有多少种是合法的括号序列？
  - 递推式：`f[n] = f[0] * f[k-1] + ... + f[k-1] * f[0]`；
  - 初始条件：`f[0] = 1`，因为`0`对括号只能组成一种括号序列（空序列）；
  - 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
int n, f[100010];

int main() {
    cin >> n;
    f[0] = 1; // 初始条件
    for( int i = 1; i <= n; ++i ) { // 求f[i]的值
        for( int k = 0; k < i; ++k ) {
            f[i] += int((long long)f[k] * f[i-k-1] % MOD); // 递推式
            // 注意，两个int相乘的结果可能爆int，因此乘法的过程要转换成long long以避免整数溢出
            f[i] %= MOD; // 记得取模
        }
    }
    cout << f[n] << endl;
    return 0;
}
```

- 时间复杂度：`O(n^2)`。




## 练习

### 求斐波那契数列

斐波那契数列是指这样的数列：第一个数和第二个数都为 1，接下来每个数都等于前面两个数之和。编程输入一个正整数 k，输出斐波那契数列第 k 个数。

输入描述：

一行一个正整数 k，3≤k≤46。

输出描述：

一行一个正整数，表示斐波那契数列第 k 个数的大小。

示例 1：

输入：

```
3
```

输出：

```
2
```







### 贴瓷砖

有一块大小是 2*n 的墙面，现在需要用2种规格的瓷砖铺满，瓷砖规格分别是 2 * 1 和 2 * 2，请计算一共有多少种铺设的方法。

输入描述：

输入的第一行包含一个正整数T（T<=20），表示一共有T组数据，接着是T行数据，每行包含一个正整数N（N<=30），表示墙面的大小是2行N列。

输出描述：

输出一共有多少种铺设的方法，每组数据的输出占一行。

示例 1：

输入：

```
3
2
8
12
```

输出：

```
3
171
2731
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 


int f[50];

int main() {
    // 请补全代码，实现题目功能
    f[1] = 1;
    f[2] = 3;
    for (int i = 3; i <= 30; i++)
        f[i] = f[i - 1] + f[i - 2] * 2;
    int a, t;
    cin >> t;
    while (t--) {
        cin >> a;
        cout << f[a] << endl;
    }
    return 0;
}

```



