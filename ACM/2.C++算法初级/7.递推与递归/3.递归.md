# 递归

---

## 这就是递归

**递归简介**

**递归**，简单地来说，就是一个函数自己调用自己。

比如下面的代码，就是一个很简单的递归代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

void f() {
    f(); // f函数调用自己
}

int main() {
    f();
    return 0;
}
```

**但是**！上面这段代码有个致命的问题，你能发现吗～
答：代码有语义错误，运行后会有问题。





## 两个关键问题



```cpp
#include <bits/stdc++.h>
using namespace std;

void f() {
    f(); // f函数调用自己
}

int main() {
    f();
    return 0;
}
```

上述这段代码在理论上来讲会陷入**死循环**哦，因为`f()`函数不停地调用自己，永远没有停止的机会。

![img](https://staticcdn.boyuai.com/user-assets/5085/1SQPN5E2tAe1pSUgzeS3os/1.png!png)

注意！这里的流程图是“一条道走到黑”的线性形状，而不是下图一样的循环形状：

![img](https://staticcdn.boyuai.com/user-assets/5085/4L4ZShUDfvGinUiPizctGU/2.png!png)

> **关键问题1**：这是因为，每次我们调用一个函数的时候，系统都会为这个函数分配一块**与众不同的全新的空间**，用来存放这个函数所需要的数据等信息。所以，我们调用了这么多次函数`f()`，实际上这些函数`f()`是**不同的函数**，它们所拥有的**数据**各不相同，它们各自拥有的数据的存放位置也各不相同，它们唯一相同的，就是它们的代码是一样的，它们的名字都叫函数`f()`。
>
> **关键问题2**：函数`f()`就好像是工厂中生产零件的模板，每次我们调用函数`f()`的时候，都会依照模板生产一个**新的零件**，名字叫“函数`f()`”。我们调用了很多次函数`f()`，也就是生产了很多名字相同的零件，它们的模样也相同，但是它们是不同的零件，因为我对一个零件操作不会影响到其他零件。

以上这两段话其实是编程语言函数调用机制的基础内容，如果你不能理解或者忘记了，请复习相关内容，否则你是无法真正理解**递归**的，更谈不上用**递归**解题。

![img](https://staticcdn.boyuai.com/user-assets/5085/V2XLB1yn6T2XzBTGF6frTK/3.png!png)

另外，两个函数相互调用也算是**递归**的一种，只要涉及到“函数自己调用自己”，都可以称为**递归**。

```cpp
#include <bits/stdc++.h>
using namespace std;

void g();

void f() {
    g(); // f调用g
}

void g() {
    f(); // g调用f
}

int main() {
    f();
    return 0;
}
```



## **递归求阶乘**

> 输入非负整数n，使用递归法求出n的阶乘，答案对998244353取模。

我们设`f(n)`为n的阶乘，那么根据阶乘的定义，我们可以得到：

- `f(0) = 1 // 初始值`
- `f(n) = f(n-1) * n // 递归公式`

有了这两条，我们就可以写出递归代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int f( int n ) {
    if( n == 0 ) 
        return 1;    // 0的阶乘等于1
    else return 
        (long long)f(n-1) * n % MOD; // 注意取模，小心爆int
}

int main() {
    int n;
    cin >> n;
    cout << f(n) << endl;
    return 0;
}
```

代码简洁易懂，只是把我们得到的两条公式直接塞到了代码中而已。

然而初学者面对这样的代码，往往会一脸迷惑：这样就够了吗？我怎么总感觉这代码少了点啥？

**是的，这样就够了。**

我们接下来会分析代码的执行流程，体会**递归**是如何运作的。

不妨假设我们要计算的是`f(5)`，那么执行流程如下：

- 执行`f(5)`，进入`else`语句，要求执行`f(4)`。
- 执行`f(4)`，进入`else`语句，要求执行`f(3)`。
- 执行`f(3)`，进入`else`语句，要求执行`f(2)`。
- 执行`f(2)`，进入`else`语句，要求执行`f(1)`。
- 执行`f(1)`，进入`else`语句，要求执行`f(0)`。
- 执行`f(0)`，进入`if`语句，返回`1`。
- `f(1)`接收到`f(0)`返回的`1`，把这个`1`和`1`相乘，得到`1`，并返回。
- `f(2)`接收到`f(1)`返回的`1`，把这个`1`和`2`相乘，得到`2`，并返回。
- `f(3)`接收到`f(2)`返回的`2`，把这个`2`和`3`相乘，得到`6`，并返回。
- `f(4)`接收到`f(3)`返回的`6`，把这个`6`和`4`相乘，得到`24`，并返回。
- `f(5)`接收到`f(4)`返回的`24`，把这个`24`和`5`相乘，得到`120`，并返回。

这就是`f(5)`的执行流程，最终得到了我们期望的结果——120。

容易发现，**递归**的执行过程是“**从上到下，再回到上**”：

- 我们最开始是想知道`f(5)`的答案，但是想要知道`f(5)`就必须知道`f(4)`
- 想要知道`f(4)`就必须知道`f(3)`
- ……如此刨根问底，最后到了`f(0)`
- 我们直接得到了答案，然后再一层一层地返回，逐渐融合成我们想要的答案

因此，我们也可以分析出，该算法的**时间复杂度**是`O(n)`：“**从上到下**”的过程是`O(n)`，“**再回到上**”的过程也是`O(n)`，加起来一共是`O(n)`。



```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int n = 10; // 求10的阶乘

int f( int n ) {
    // TODO 请补全下述代码
    if( n == 0 ) 
        return 1;     // 0的阶乘等于1
    else 
        // TODO 请补全下述代码
        return (long long)f(n-1)*n%MOD ; // 注意取模，小心爆int
}

int main() {
    cout << f(n) << endl;
    return 0;
}

```





## 递归求斐波那契数列

上一节中，看起来**递归**很好理解，只需要一层一层地剥开，研究清楚如何“**从上到下**”地刨根问底，再研究清楚如何在“**回到上**”的过程中求出答案，就可以了？

果真如此吗？

让我们再来看一个问题：

**递归求斐波那契数列**

> 输入正整数n，使用递归法求出斐波那契数列的第n项，答案对998244353取模。

比葫芦画瓢，我们可以直接列出斐波那契数列的数学公式：

- `f(1) = f(2) = 1 // 初始值`
- `f(n) = f(n-1) + f(n-2) // 递归公式`

然后直接把它们写进代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int f( int n ) {
    if( n == 1 || n == 2 ) 
        return 1; // 边界条件
    else 
        return (f(n-1) + f(n-2)) % MOD; // 不要忘记取模
}

int main() {
    int n;
    cin >> n;
    cout << f(n) << endl;
    return 0;
}
```

接下来，我们继续比葫芦画瓢，尝试分析这个算法的正确性和复杂度，以`f(10)`为例子：

![img](https://staticcdn.boyuai.com/user-assets/5085/d8ad6MZejjhrZTF7gxEBGi/4.png!png)

如果我们继续使用“一层一层全部剥开”的方法去分析正确性和复杂度，我们发现这样做的麻烦程度简直超乎我们的想象。如果我们的**递归**函数里面还有各种各样的分支、循环，甚至是两个递归函数相互调用……我们使用这样的分析方法根本无从下手，我们需要更好更快的分析方法！

**递归的本质是数学归纳法**

我们在高中的数学课本中学过**数学归纳法**，现在它是时候派上用场了！

我们使用**数学归纳法**分析上述“求斐波那契数列算法”的正确性：

- `f(1)`可以得到正确答案，由`if`语句保证
- `f(2)`可以得到正确答案，由`if`语句保证
- 如果`f(n-1)`和`f(n-2)`都可以得到正确答案，那么`f(n)`可以得到正确答案，由`else`语句保证
- 因此，对于任意的正整数`n`，我们的算法都是正确的

是的，这就结束了！

我们完全不需要一层一层地剥开所有的递归，那是计算机才需要做的体力活，我们的人脑无法承受这种工作量。

实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int n = 10; // 求出斐波那契数列的第10项

int f( int n ) {
    // TODO 请补全下述代码
    if( n == 1 || n == 2 )   // 边界条件
        return 1; 
    else 
        // TODO 请补全下述代码
        return (f(n-1) + f(n-2))%MOD ; // 不要忘记取模
}

int main() {
    cout << f(n) << endl;
    return 0;
}
```





## 从归纳的角度思考递归

对于任意的**递归**函数，我们都可以从**数学归纳法**的角度去理解它，再抽象一点，就是：

1. 这个函数设计出来的目的是什么？

   > 求斐波那契数列。

2. 在边界条件上，这个函数正确吗？

   > 正确。

3. 这个函数能正确利用递归处理出来的结果吗？

   > 可以正确使用。

4. 因此这个函数是正确的。

**第一点**尤为重要！在理解一个**递归**函数之前，我们必须知道这个函数的**目的**是要干什么，这样才能使用数学归纳法。

这也警示我们，在写递归函数的时候，

**不要让一个函数干两件事情**！

**不要让一个函数干两件事情**！

**不要让一个函数干两件事情**！

只有每个函数干**唯一**指定的事情，才能保证写出来的代码是**可靠易读易修改**的。

**第二点**是我们大家都能想到的点，但是经常会忘记一些特殊情况导致漏写边界条件。在结果出问题的时候，需要检查一下是不是有什么边界条件忘记了。

**第三点**是递归最难理解的地方，这里分享一个小窍门：

> 在一个函数递归调用自己的时候，我们可以直接假设这个函数是一个已经写完，并且功能完善的函数，它能保质保量地完成我们想让它做的事情（这其实就是数学归纳法的前提假设）。
>
> 千万不要把递归函数展开，千万不要尝试研究递归的过程是什么样的，因为人脑根本无法承受如此大的数据量，我们只能用数学归纳法来保证递归函数的正确性。
>
> 同时，这也是为什么我们要求在写函数之前想好这个函数的任务，并且在写函数的过程中，这个任务始终不能变化，因为这是我们使用数学归纳法的前提，我们需要假设这个函数能完美地完成这个任务，才可以肆无忌惮地放心递归调用它。

那么，函数的正确性我们已经理解了，**复杂度**如何分析呢？

由于**递归**函数总是**在边界条件处结束**，因此我们可以重点**关注边界条件被执行的次数**，粗略地估计算法的复杂度。

之所以是粗略地估计，是因为递归函数的复杂度往往**不稳定**，我们一般无法得到一个精确的值，只能粗略估计。

比如求斐波那契数列的算法:

边界条件`if( n == 1 || n == 2 ) return 1;`执行的次数，其实就等于这个斐波那契数本身（这个数是由这样的1累计起来的），比如计算`f(10)`的复杂度就至少是`O(f(10))`，计算`f(n)`的复杂度就至少是`O(f(n))`，我们可以粗略地将这个算法的复杂度估计为“指数级”（因为斐波那契数本身的增长速度就是指数级）。这就足够了。

上面讲了如何理解一个递归算法，那么我们如何自己用递归算法解决问题呢？

仍然是牢记这三板斧：

1. 确认并牢记这个递归函数的功能，始终不能改。
2. 仔细检查，写对边界条件。
3. 递归调用自己时，放心大胆地用，假设这个函数就是对的。

纸上得来终觉浅，绝知此事要躬行。递归对于初学者来说是很难掌握的算法，同时也是计算机思维很好的体现。大家一定要勤加练习，先尝试读懂别人的**递归**代码，再尝试自己设计**递归**算法。相信你一定能掌握**递归**的奥妙。



## 总结

- 递归是一个函数自己调用自己。
- 递归的本质是数学归纳法。

> 我们总是需要从数学归纳法的角度去思考递归，永远不要尝试展开递归过程。

- **斐波那契数列问题**：输入正整数n，使用递归法求出斐波那契数列的第n项，答案对998244353取模。
  - 数学公式：
    - `f(1) = f(2) = 1 // 初始值`
    - `f(n) = f(n-1) + f(n-2) // 递归公式`
  - 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int f( int n ) {
    if( n == 1 || n == 2 ) 
        return 1; // 边界条件
    else 
        return (f(n-1) + f(n-2)) % MOD; // 不要忘记取模
}

int main() {
    int n;
    cin >> n;
    cout << f(n) << endl;
    return 0;
}
```

- **求阶乘问题**：输入非负整数n，使用递归法求出n的阶乘，答案对998244353取模。
  - 数学公式：
    - `f(0) = 1 // 初始值`
    - `f(n) = f(n-1) * n // 递归公式`
  - 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;

int f( int n ) {
    if( n == 0 ) 
        return 1;    // 0的阶乘等于1
    else return 
        (long long)f(n-1) * n % MOD; // 注意取模，小心爆int
}

int main() {
    int n;
    cin >> n;
    cout << f(n) << endl;
    return 0;
}
```

- 理解递归的三板斧：
  1. 确认并牢记这个递归函数的功能，始终不能改。
  2. 仔细检查，写对边界条件。
  3. 递归调用自己时，放心大胆地用，假设这个函数就是对的。
- 写递归算法时，要牢记该函数**只**干一件事情，要写出所有**边界条件**，要放心大胆地递归调用自己。
- 递归算法的复杂度往往难以精确把握，只需要根据边界条件的执行次数和递归调用次数估算即可。



## 练习

### 倒序输出

输入一个自然数，输出它的倒序数。

输入描述：

一个正整数

输出描述：

这个正整数的倒序数

示例 1：

输入：

```
1234
```

输出：

```
4321
```

实现

```cpp
#include <iostream>
using namespace std;

// TODO 请补全下述代码，完成递归函数
void daoxu(int n){
	if (n < 10)
        cout << n;
    else{
        cout << n % 10;
        daoxu(n / 10); // 递归
    }   
}

int main(){
    int n;
    cin >> n;
    daoxu(n);
    return 0;
}
```





### 汉诺塔

左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间需要遵循以下原则：

一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤。若将A最上面的盘子移动到B上，则可表示为 "A -> B"。

![](https://img2022.cnblogs.com/blog/1571518/202204/1571518-20220421144653684-1615631593.png)

输入描述：

一行，一个整数n (n <= 20)。


输出描述：

若干行，每行代表一次操作。

比如：

A -> B


示例 1：

输入：

```
2
```

输出：

```
A -> B
A -> C
B -> C
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

void hanoi(int n, char a, char b, char c) {
    if (n == 1) {
        printf("%c -> %c\n", a, c);
        return;
    }
    hanoi(n - 1, a, c, b);
    printf("%c -> %c\n", a, c);
    hanoi(n - 1, b, a, c);
    return;
}

int main() {
    // 请补全代码，实现题目功能
    int n;
    cin >> n;
    hanoi(n, 'A', 'B', 'C');
    return 0;
}

```



### 最大公约数

求两个正整数`ｍ ｎ`的最大公约数。已知：当`m > n`且`m % n != 0`时，`gcd(m, n) = gcd(n, m % n)`，其中`gcd(m, n)`表示`m n`的最大公约数。

输入描述：

一行，两个正整数，表示`m n`。

输出描述：

一个数，表示最大公约数。

示例 1：

输入：

```
12 18
```

输出：

```
6
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int gcd (int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}


int main() {
    // 请补全代码，实现题目功能
	int a, b;
    cin >> a >> b;
    if (a < b)
        swap(a, b);
    cout << gcd(a, b);
    return 0;
}
```





