# 动态规划

---

## 最优化问题

生活中我们常常遇到这样一些问题：

> **举例——接水问题**
>
> 有n个人，每个人接水时间为$t_i$，现在只有一个水龙头，请问如何安排n个人的顺序，使得每个人的平均等待时间最少？

> **举例——旅行商问题**
>
> 给定n个城市，两两城市之间都有公路连接，并且连接i城市和j城市之间的公路距离为$w_{i, j}$。现有一个旅行商，希望从一个点出发，经过所有城市，再回到起始点。并且，旅行商只愿意经过每个城市一次。请问整个过程的最短距离是多少？

> **举例——背包问题**
>
> 给定n个物品，每个物体有个体积$v_i$和一个价值$p_i$。现有一个容量为V的背包，请问如何选择物品装入背包，使得获得的总价值最大？

看到上面的例子，我们发现这些问题都是**在最大化（或者最小化）某个指标**：最小化平均等待时间、最小化总旅行路程、最大化背包里的物品个数。这种类型的问题我们一般称为**最优化问题**。

> **最优化问题**（**optimization problem**）是在一些约束下，通过进行一些决策，使得最终获益最大（或损失最小）的一类问题。

可以感受到，**最优化问题**和现实中的生产和生活场景联系非常紧密。所以，解决**最优化问题**，是一个非常重要的课题。


## 数字金字塔问题

**观察下面的数字金字塔**：

![img](https://staticcdn.boyuai.com/user-assets/5085/PQpnJLLkmmPxDXU84MubU7/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg!jpg)

现在，需要我们找到一种方法，查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。

> 注：每一步可以走到左下方的点也可以到达右下方的点。

比如，在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$的路径经过数字的和最大。

现在，我们把数字金字塔转化成一个算法问题，就变成了：

> 给定一个n层的金字塔，求一条从最高点到底层任意点的路径使得路径经过的数字之和最大。
>
> 注：每一步可以走到左下方的点也可以到达右下方的点。

### 分析

**基本思路**

我们按照下面的步骤依次观察这个问题的结构：

1. 首先，因为我们可以走到最下面一层的任意点。那么，只要我们能够**分别求出到达每个点的最大路径**，然后在所有点里面取最大值即可解决这个问题。

2. **下面我们仅考虑走到最下面一层确定点的最大路径**。假设我们现在想求走到最下面一层中间的22的最大路径，**最暴力的方法就是列举所有走到22的路径**，然后取路径和最大的一条作为答案。所以，所有走到22的路径如下：
   $$
   \textcolor{red}{(7 \to 3 \to 8 \to 7 \to 2) \qquad 7 + 3 + 8 + 7 + 2 = 27}
   $$

   $$
   (7 \to 3 \to 1 \to 7 \to 2) \qquad 7 + 3 + 1 + 7 + 2 = 20
   $$

   $$
   (7 \to 3 \to 1 \to 4 \to 2) \qquad 7 + 3 + 1 + 4 + 2 = 17
   $$

   $$
   (7 \to 8 \to 1 \to 7 \to 2) \qquad 7 + 8 + 1 + 7 + 2 = 25
   $$

   $$
   (7 \to 8 \to 1 \to 4 \to 2) \qquad 7 + 8 + 1 + 4 + 2 = 22
   $$

   $$
   (7 \to 8 \to 0 \to 4 \to 2) \qquad 7 + 8 + 0 + 4 + 2 = 21
   $$

   所以，最终走到22的路径里面，数字和最大是2727。

3. 我们进一步观察所有走到22的路径。因为它的路径只可能从上面两个方向走下来。所以如下图，所有走到`2`的路径可以被分成两类：从77走过过来的路径和从44走过来的路径。

![img](https://staticcdn.boyuai.com/user-assets/5085/k7RJp8B5jHgr5JRRhoGC84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.jpg!jpg)

1. 对于所有结尾是77的路径

$$
(7 \to 3 \to 8 \to 7) \qquad 7 + 3 + 8 + 7 = 25
$$

$$
(7 \to 3 \to 1 \to 7) \qquad 7 + 3 + 1 + 7 = 18
$$

$$
(7 \to 8 \to 1 \to 7) \qquad 7 + 8 + 1 + 7 = 23
$$

我们只需要接上一段$\to 2$，就可以变成从最上面的结点走到22的路径：
$$
(7 \to 3 \to 8 \to 7 \textcolor{red}{\to 2}) \qquad 7 + 3 + 8 + 7 \textcolor{red}{+2} = 27
$$

$$
(7 \to 3 \to 1 \to 7 \textcolor{red}{\to 2}) \qquad 7 + 3 + 1 + 7 \textcolor{red}{+2} = 20
$$

$$
(7 \to 8 \to 1 \to 7 \textcolor{red}{\to 2}) \qquad 7 + 8 + 1 + 7 \textcolor{red}{+2} = 25
$$

但是，如果我们已经知道“到达77的路径”里面**第2条路经和第3条路径不如第1条路径**，是不是就可以直接舍弃下面两条，只考虑经由第1条路径走到22的情况？也就是说，为了求所有“经由77走到22”的路径里面，我们只需要计算下面**一条路径**即可：
$$
(7 \to 3 \to 8 \to 7 \textcolor{red}{\to 2}) \qquad 7 + 3 + 8 + 7 \textcolor{red}{+2} = 27
$$
同样，对于所有“经由44走到22”的路径里面，我们也只需要挑选到达44最大的一条，然后将\to 2→2接在后面。
$$
(7 \to 8 \to 1 \to 4 \textcolor{red}{\to 2}) \qquad 7 + 8 + 1 + 4 \textcolor{red}{+2} = 22
$$

1. 那么因为“从三角形顶端到达22”的路径里面，只有上面两种情况，所以，它们之间的的较大值就是到达22的最大路径，也就是

$$
\max\{27, 22\} = 27
$$

2. 可是如此一来，我们不需要枚举所有”从顶点到达2“的路径。但为了找出两种情况下各自的最大值，看起来我们仍需要枚举”从顶点到达7“和”从顶点到达4“的路径。

但是，我们发现，**找到”从顶点到达7“和”从顶点到达4“的最大路径，就是一个和原问题”从顶点到达2“结构相似的问题**！另外，由于77和44的位置比22要少一行，所以实际上，**这两个问题是一个规模更小的问题**！也就是说，这两个问题是原问题的一个**子问题**！那么，我们利用和上面类似的分析思路，就可以不用枚举所有到达77和44的路径了。



### 数字金字塔问题算法描述

![img](https://staticcdn.boyuai.com/user-assets/5085/PQpnJLLkmmPxDXU84MubU7/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg!jpg)

> 给定一个n层的金字塔，求一条从最高点到底层任意点的路径使得路径经过的数字之和最大。
>
> 注：每一步可以走到左下方的点也可以到达右下方的点。

这里，我们把上一步的基本思路形式化成一个严谨的算法：

1. 我们用`a[i][j]`存储数字金字塔第`i`行第`j`列的数字，用`f[i][j]`表示”从顶点到达第`i`行第`j`列“的所有路径中最大的数字和。

2. 对于顶点，因为它是起始点，所以`f[1][1] = a[1][1]`。

3. 因为到达`(i, j)`的路径最多只可能从`(i - 1, j - 1)`和`(i - 1, j)`两个点走过来（如果在三角形的最左边或者最右边，那么它的上一个结点就只有一种情况），所以，我们有下面的关系：

   ```C++
    f[i][j] = f[i - 1][j - 1] + a[i][j]；                    // i == j
    f[i][j] = f[i - 1][j]     + a[i][j]；                    // j == 1
    f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]；  // otherwise
   ```

   那么，观察这个等式，会发现如果我们已知`f[i - 1][j - 1]`和`f[i - 1][j]`，就可以求出`f[i][j]`。所以实际上，它有点像一个特殊形式的递推：有**初始状态**和**递推关系**。那么我们通过一个二重循环就可以求出所有`f[i][j]`。

4. 最后，我们输出所有`f[n][j]`对于所有`(1<=j && j<=n)`的最大值即可。



实现

```cpp
#include <bits/stdc++.h>
#define N 1005
#define M 110
using namespace std;

int n = 5; // 数字金字塔有5行
/* 数字金字塔:
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
*/
int a[N][N] = {{0}, {0, 7}, {0, 3, 8}, {0, 8, 1, 0}, {0, 2, 7, 4, 4}, {0, 4, 5, 2, 6, 5}};
int f[N][N];


int main() {

    // 动态规划过程
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= i; ++j)
            if (i == j) {
                f[i][j] = f[i - 1][j - 1] + a[i][j];// TODO 请补全代码
            } else if (j == 1) {
                f[i][j] = f[i - 1][j] + a[i][j];// TODO 请补全代码
            } else {
                f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; // TODO 请补全代码
            }
    
            
    // 输出
    int ans = 0;
    for (int i = 1; i <= n; ++i) 
        ans = max(ans, f[n][i]);	// 求第n行的最大值
    cout << ans << endl;
    
    return 0;
}
```



### 数字金字塔完整代码实现

![img](https://staticcdn.boyuai.com/user-assets/5085/PQpnJLLkmmPxDXU84MubU7/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg!jpg)

> 【数字金字塔】
>
> 给定一个n层的金字塔，求一条从最高点到底层任意点的路径使得路径经过的数字之和最大。
>
> 注：每一步可以走到左下方的点也可以到达右下方的点。

#### 代码实现

动态规划的代码实现相对简单，基本上是使用循环来计算递推序列的过程。下面直接给出代码：

```c++
#include <bits/stdc++.h>
#define N 1005
#define M 110
using namespace std;

int n;

int a[N][N], f[N][N];

int main() {
    // 输入
	cin >> n;
	for (int i = 1; i <= n; ++i) 
		for (int j = 1; j <= i; ++j)
			cin >> a[i][j];
			
    // 动态规划过程
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= i; ++j)
			f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
    		// 此处没有讨论 j == 1 和 i == j 的情况
    		// 是因为当 j == 1 时，f[i - 1][j] == 0
    		// 是因为在数字金字塔所有数字都是正数的情况下
    		// max函数一定不会选择用f[i - 1][j]来转移
    		// i == j 的情况同理
			
    // 输出
	int ans = 0;
	for (int i = 1; i <= n; ++i) ans = max(ans, f[n][i]);	// 求第n行的最大值
	cout << ans << endl;
	
	return 0;
}
```

#### 复杂度分析

**空间复杂度**

该问题的空间复杂度是$O(n^2)$。

**时间复杂度**

动态规划因为大部分都是由一些for循环组成，所以复杂度分析相对简单。在本例中，因为有两层`for`循环，并且都是n左右的数量级，所以整个算法的复杂度为$O(n^2)$。





## 动态规划分析流程和条件

现在让我们一起总结一下**动态规划分析流程和条件**：

### 首先是动态规划分析流程：

在**数字金字塔**的分析中我们发现，用**动态规划**解决问题的过程，就是一个把原问题的过程变成一个**阶段性决策**的过程。

比如在**数字金字塔**问题中，路径每往下延伸一行，我们就进行到下一个**阶段**，或者步骤。而在每一个步骤里，我们需要**决策**到底是从左上过来，还是从右上过来。在运用动态规划方法分析问题的过程中，下面四个要素是要明确的：

1. **状态**。**状态用于描述每一个步骤的参数以及结果**。在数字金字塔的例子中，每个`f[i][j]`表示的就是一个状态。其中数组下标是当前路径的结尾，而值是以`i`行`j`列元素为结尾的所有路径中的最大值。
2. **转移方程**。**转移方程用于描述不同状态之间的关系**。在上面的例子中，`f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]`就是一条转移方程。它描述了结尾为下一行的第`j`个结点的路径，和以上一行第`j-1`个结点和第`j`个结点路径之间的关系。
3. **初始状态**。**初始状态描述的是整个转移方程推导的开始，是不需要经由别的状态就知道结果的状态**。上面的例子中，`f[1][1]=a[i][j]`就是初始状态。我们以这个状态为起点，最终推导出整个三角形上每一个位置的答案。
4. **转移方向**。**转移方向描述的是推导出不同状态的解的先后关系**。我们之所以要明确转移方向，是因为我们不希望"已知B状态只能由A状态推到过来。但是当我们想推导B时，发现A状态的结果我们还不知道”类似的事情发生。比如由转移方程中`f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]`，我们发现，如果想推导`f[i][j]`，必须先推导`f[i - 1][j - 1]`和`f[i - 1][j]`。所以，按照`i`从小到大，`j`从小到大的顺序推导是一种可行的推导方向。

所以，为了用动态规划解决问题，我们就需要明确上面四个方面，其中最重要的就是设计**状态**和**转移方程**。





### 动态规划分析流程和条件

#### 动态规划条件

那么，是不是所有最优化类问题都能用动态规划来解决呢？

**不是**。

那么，使用动态规划需要满足什么条件？

在这里指出，用动态规划求解要求我们设计出状态和转移方程，使得它们满足下面三个条件：

1. **最优子结构**：**原问题的最优解**，**必然是通过子问题的最优解得到的**。比如上面的例子中，我们提过，如果所有以77为结尾的路径里面，有一条的数字和最大。那么，在所有经由77到达22的路径里，我们一定选择到达77的和最大的一条。所以，这样的问题具有最优子结构的性质。
2. **无后效性**：**前面状态的决策不会限制到后面的决策**。比如说数字金字塔问题里，无论以任何方式走到77，我们都可以在后面接一段从77走到22，变成一条到达22的路径。所以，数字金字塔没有后效性。但是，在旅行商问题里，如果我们从11号城市开始，走到33号城市，那么途中经没经过22号，将会影响到33号城市后面的路径。这个场景就是有后效性的例子。
3. **重复子问题**：**一个子问题可以被重复利用到多个父亲状态中**。我们发现在下面这张图中，`f[3][2]`既可以用来更新`f[4][2]`，又可以用来更新`f[4][3]`。那么，因为我们把它存在数组里，所以只需要计算一次`f[3][2]`，就可以使用很多次。也就是说，`f[4][2]`和`f[4][3]`有个共同的子问题`f[3][2]`。

![img](https://staticcdn.boyuai.com/user-assets/5085/LDfr3LwuP56ioDCxTBvULx/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923.jpg!jpg)

动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。

动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。

选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。



## 总结

- **动态规划**是一种**解决某种最优化问题**的方法。

> 最优化问题的目的就是在一些场景限制下，通过不同的决策，达到最大收益或者最小损失。

- 使用动态规划的**条件**是：**最优子结构**、**无后效性**和**重复子问题**。
  - 最优子结构保证了我们能够通过选取子问题的最优解最终拼成原问题的解；
  - 无后效性保证了整个过程的推导是同一个方向的，不会出现环的情况；
  - 重复子问题一定程度上保证了总状态个数不会与每个状态的选择数呈指数增长。
- 使用**动态规划**解决问题，需要**明确状态设计**、**转移方程**、**初始状态**和**转移方向**四个方面。这样，我们就可以用类似根据**递推式**计算数列第n项的方法得到最终结果。

![img](https://staticcdn.boyuai.com/user-assets/5085/PQpnJLLkmmPxDXU84MubU7/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg!jpg)

- **数字金字塔问题**：给定一个n层的金字塔，求一条从最高点到底层任意点的路径使得路径经过的数字之和最大。注：每一步可以走到左下方的点也可以到达右下方的点。
  - 完整代码：

```c++
#include <bits/stdc++.h>
#define N 1005
#define M 110
using namespace std;

int n;
int a[N][N], f[N][N];

int main() {
    // 输入
	cin >> n;
	for (int i = 1; i <= n; ++i) 
		for (int j = 1; j <= i; ++j)
			cin >> a[i][j];
			
    // 动态规划过程
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= i; ++j)
			f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
    		// 此处没有讨论 j == 1 和 i == j 的情况
    		// 是因为当 j == 1 时，f[i - 1][j] == 0
    		// 是因为在数字金字塔所有数字都是正数的情况下
    		// max函数一定不会选择用f[i - 1][j]来转移
    		// i == j 的情况同理
			
    // 输出
	int ans = 0;
	for (int i = 1; i <= n; ++i) ans = max(ans, f[n][i]);	// 求第n行的最大值
	cout << ans << endl;
	
	return 0;
}
```

- 复杂度分析
  - **空间复杂度**: **数字金字塔**的空间复杂度是$O(n^2)$。
  - **时间复杂度**：动态规划因为大部分都是由一些for循环组成，所以复杂度分析相对简单。在本例中，因为有两层`for`循环，并且都是n左右的数量级，所以整个算法的复杂度为$O(n^2))$。
- 动态规划算法的关键在于解决冗余，舍空间而取时间。





## 练习

### 最大子段和

给出一个长度为 n 的序列 a，选出其中连续且非空的一段使得这段和最大。

输入描述：

第一行是一个整数，表示序列的长度 n。

第二行有 n个整数，第 i*i* 个整数表示序列的第 i*i* 个数字$a_i$。


输出描述：

输出一行一个整数表示答案。

示例 1：

输入：

```
7
2 -4 3 -1 2 -4 3
```

输出：

```
4
```

实现

```cpp
#include <bits/stdc++.h>
#define N 100000
using namespace std;

int n;
int a[N]; 
int b[N]; // 用于存储当前位置元素的最大字段和

int main() {
    // 输入
	cin >> n;
	for (int i = 0; i < n; ++i) 
		cin >> a[i];
    b[0] = a[0];
			
    // TODO 请补全下述代码，完成动态规划过程
	for (int i = 1; i <= n; ++i)
        if (b[i - 1] < 0) {
            b[i] = a[i]; 
        } else { 
            b[i] = b[i-1] + a[i];
        }
      
    // 输出
	int ans = 0;
	for (int i = 0; i < n; ++i) 
        ans = max(ans, b[i]);	// 求第n行的最大值
	cout << ans << endl;
	
	return 0;
}

```



### 数字金字塔

给定一个`n (n <= 200)`层的金字塔，求一条从最高点到底层任意点的路径使得路径经过的数字之和最大。

输入描述：

第一行一个整数`n`，表示该数字金字塔的高度。

接下来共`n`行，第`i`行有`i-1`个整数，中间空格分隔。

输出描述：

一行，一个整数，表示所经过数字的最大和。

示例 1：

输入：

```
6
2
96 30
83 52 60
21 65 44 61
8 79 50 41 21
61 41 50 38 79 10
```

输出：

```
375
```


实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[210][210], f[210][210];

int main() {
    // 请补全代码，实现题目功能
    int n, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++) {
            f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
            ans = max(ans, f[i][j]);
        }
    cout << ans << endl;
    return 0;
}
```



### 最长上升子序列

给定一个长度为`n`的序列，在其中找出一个子序列，并且满足该序列中的数字单调上升，那么该子序列最长的长度是多少。

输入描述：

第一行一个整数`n (1 ≤ n ≤ 1000)`，表示该序列的长度。

第二行`n`个整数，表示该序列，中间用空格隔开。

输出描述：

一行一个整数，表示最长的长度。

示例 1：

输入：

```
5
1 4 3 2 5
```

输出：

```
3
```
实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[1010], f[1010];

int main() {
    // 请补全代码，实现题目功能
    int n, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        f[i] = 1;
        for (int j = 1; j < i ; j++)
            if (a[j] < a[i]) 
                f[i] = max(f[j] + 1, f[i]);
        ans = max(ans, f[i]);
    }
    cout << ans << endl;
    return 0;
}
```


