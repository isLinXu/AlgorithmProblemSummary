# 0-1背包问题

---

## 辰辰采药

有这样一个问题：

> **辰辰采药**
>
> 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
>
> 如果你是辰辰，你能完成这个任务吗？

**辰辰采药**在算法中属于一种很经典的**0-1背包问题**。更一般的，这种问题可以转化为：

> 给定n个物品，每个物体有个体积$v_i$和一个价值$p_i$。现有一个容量为V的背包，请问如何选择物品装入背包，使得获得的总价值最大？

0-1背包问题分析

**0-1背包问题描述**

> 给定n*n*个物品，每个物体有个体积v_i*v**i*和一个价值p_i*p**i*。现有一个容量为V*V*的背包，请问如何选择物品装入背包，使得获得的总价值最大？

### 基本思路

考虑到现在我们能做的决策，只有对于每个物品的“**选**”与“**不选**”。所以，这个问题就是

- 以“**将每一个物品依次放入背包**”划分**不同阶段**
- 而对于每个物品的“**选与不选**”就是**不同决策**

考虑到所有的放置前i*i*个物品的方案数可以分为两类：

- 一个是放第i*i*个物品，
- 一个是不放第i*i*个物品

所以下面我们分这两种情况来讨论。因为在决策的过程中，变化的是当前所在的阶段，以及容量的剩余大小。

所以，我们维护一个**二维状态**$f[i, j]$, 来表示前$i$个物品，放到体积为$j$的背包里，可以得到的最大价值。

**首先**，考虑容量为**任意值$j$时，**将前$i$个物品放入背包的情况**。

- 如果我们**不选择第i个物品**，那么总共j*j*大小的背包空间相当于都用来放前$(i - 1)$的物品。那么我们如果想收益最大，就应该在前$i-1$个物品中选一个最优秀的子集。而解决”**对于前i-1个物品，容量为$j$的背包，能获得的最大收益**”就变成了一个**子问题**！

所以，当前的答案应该等于$f[i - 1, j]$。如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/xebBCy2Rz3RV66xYr6gj4F/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpg!jpg)

- 另一种决策就是**选择第i个物品**。当我们一定选择第$i$个物品时，整个背包一定要分出$v[i]$的空间来放它。这样一来，一个容量为$j$的背包里，只剩下$j - v[i]$的空间来放前i - 1个物品了。而当前这个背包中所有物品的总收益，就是第i*i*个物品的收益，加上用$j-v[i]$的空间装前$i-1$个物品的收益。我们发现，**后者就是原问题的一个子问题**！所以这种情况的最大收益是$f[i - 1][j - v[i]] + p[i]$。

![img](https://staticcdn.boyuai.com/user-assets/5085/AfeYfAVrdjQBSCjbyQn48V/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982.jpg!jpg)

**然后**，当我们讨论完到达当前状态的两种决策以及各自的收益，**我们应该选择哪种决策呢**？

当然是选择**收益更大**的那个！所以，我们有下面的式子：
$$
f[i, j] = \max\{f[i - 1, j], f[i - 1, j - v[i]] + p[i]\}
$$



## 0-1背包问题的形式化分析

> 【0-1背包问题】
>
> 给定n*n*个物品，每个物体有个体积v_i*v**i*和一个价值p_i*p**i*。现有一个容量为V*V*的背包，请问如何选择物品装入背包，使得获得的总价值最大？

还记得吗？

使用**动态规划**解决问题，需要**明确状态设计**、**转移方程**、**初始状态**和**转移方向**四个方面。

那现在，让我们来明确一下该**0-1背包问题**中的**动态规划**四要素：

1. **状态**：

> 用`f[i][j]`表示前i*i*个物品，放在空间为j*j*的背包里，能获得的最大收益。

1. **转移方程**：

> 因为每一个阶段有至多两种选择，所以需要分别计算两种选择的收益后取较大值。

```c++
f[i][j] = f[i - 1][j]									// j < v[i]，表示装不下第i个物品
f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + p[i]);	// otherwise
```

1. **初始状态**：

> 在一个物品都没放的时候，无论背包大小多少，总价值都是00，即

```c++
f[0][j] = 0 // 0 <= j <= V
```

1. **转移方向**：

> 观察转移方程，发现要想保证等式右边的状态一定比左边的状态先算出来，只需要保证i*i*从小到大计算即可。

最终该问题的答案就是$f[n, V]$。这样，**0-1背包问题**就可以使用**动态规划**来解决～



## 0-1背包问题的代码实现

### 0-1背包问题

给定n个物品，每个物体有个体积$v_i$和一个价值$p_i$。现有一个容量为$V$的背包，请问如何选择物品装入背包，使得获得的总价值最大？

#### 0-1背包中动态规划四要素：

1. **状态**：

> 用`f[i][j]`表示前i*i*个物品，放在空间为$j$的背包里，能获得的最大收益。

1. **转移方程**：

> 因为每一个阶段有至多两种选择，所以需要分别计算两种选择的收益后取较大值。

```c++
f[i][j] = f[i - 1][j];   // j < v[i]，表示装不下第i个物品
f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + p[i]);	// otherwise
```

1. **初始状态**：

> 在一个物品都没放的时候，无论背包大小多少，总价值都是00，即

```c++
f[0][j] = 0; // 0 <= j <= V
```

1. **转移方向**：

> 观察转移方程，发现要想保证等式右边的状态一定比左边的状态先算出来，只需要保证$i$从小到大计算即可。


实现

```cpp
#include <bits/stdc++.h>
#define N 1002
using namespace std;

int n = 3; 
int V = 70;
int v[N] = {0, 71, 69, 1}; // 背包中共有3个物体，体积分别为71，60，1
int p[N] = {0, 100, 1, 2}; // 背包中共有3个物体，价值分别为100，1，2
                           // 第0位，置为0，不参与计算，便于与后面的下标进行统一
int f[N][N]; 

int main() {
    
    // 动态规划
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= V; ++j) {
            if (j < v[i]) 
                f[i][j] = f[i - 1][j];    // 当前背包容量不够装第i个物品
            else 
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + p[i]); // otherwise
        }
    } 
    
    // 输出
    cout << f[n][V] << endl;
    return 0;
}
```







#### 代码复杂度分析

### 0-1背包问题

给定n个物品，每个物体有个体积$v_i$和一个价值$p_i$。现有一个容量为$V$的背包，请问如何选择物品装入背包，使得获得的总价值最大？

#### 代码实现

**动态规划**的主要工作：就是算出不同状态下的结果，然后用相应维数的数组保存。

所以，整个**动态规划**的过程就是一个”填表“的过程。

下面我们给出代码：

```c++
#include <bits/stdc++.h>
#define N 1002
using namespace std;

int n, V, v[N], p[N];
int f[N][N]; 

int main() {
    // 输入
    cin >> V >> n;		// V是总体积，n是物品总个数
    for (int i = 1; i <= n; ++i) 
        cin >> v[i] >> p[i];
    
    // 动态规划
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= V; ++j) {
            if (j < v[i]) 
                f[i][j] = f[i - 1][j];	// 当前背包容量不够装第i个物品	
            else 
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + p[i]); // otherwise
        }
    } 
	
    // 输出
    cout << f[n][V] << endl;
    return 0;
}
```



#### 复杂度分析

**空间复杂度**

因为最大用了二维数组，所以空间复杂度是$O(nV)$。

**时间复杂度**

我们可以看出，整个算法用了两个`for`循环来实现，所以**时间复杂度**是$O(nV)$。

或者我们也可以用另一个思路来分析动态规划的**时间复杂度**：

因为一共有$nV$个状态，而每个状态只需要$O(1)$的时间计算转移方程，所以总**时间复杂度**是
$$
总时间复杂度 = 状态数\times得到每个状态的时间复杂度 = nV \times O(1) = O(nV)
$$
可以看出这个算法和**物品个数**、**背包容量**都有关。

并且我们发现，这个算法可能**不适用于**背包容量**非常大（例如10^9109）**，每个物品的**体积也非常大**的情况。




### 算法优化1 —— 滚动数组优化

在动态规划中，有的时候可能内存空间比较紧张。比如说一个$O(n^2)$的算法，当n = 6000时，大概需要$3.6\times 10^7$的运算时间。可能计算机很容易在一两秒之内得出结果。但假设该问题需要一个$O(n^2)$`long long`数组，那么总内存空间为
$$
6000 \times 6000 \times 8 = 2.88 \times 10^8\text{ (Byte)} = 2.8 \times 10^5 \text{ (KB)}= 274 \text{ (MB)}
$$
这可能就超出了一些题目给定的空间大小，例如256M。所以，我们需要一些技巧来优化内存开销。

#### 滚动数组优化

因为整个动态规划的过程就是一个填表的过程，如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/zCJStrVWapuZPQVDfzf8qB/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%984.jpg!jpg)

而在本题中，填表的顺序就是：填完上一行，然后填下一行。而且我们发现，下一行的状态，只会用到上一行的状态来转移。所以，当我们在计算第i*i*行时，其实前$i-2$行的状态就都没必要保留了。所以，我们可以用一种类似于”**踩石头过河**“的思想。

试想如果我们有一些石头，想利用这些石头过河。

**如果石头的数量很多**，那么最方便的方法就是用这些石头铺一道石头路，这样我们就可以顺利过河。这就相当于我们可以开很充足的数组，然后把计算的每个阶段都存在数组里。

**但如果我们只有两块石头**，就过不了河了吗？不是的。我们可以用下图的方法一边走一边挪动石头，这样也可以顺利过河。

![img](https://staticcdn.boyuai.com/user-assets/5085/s9s3sViS27xuwWCGTqS3Qx/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%983.jpg!jpg)

在空间优化的方法中，有一种很常见就是利用过河的思想。这种方法叫做**滚动数组**。在整个算法过程中，我们只用$2\times V$的数组`f[2][V]`来记录状态。其中，所有奇数行的状态填入`f[1][j]`中，所有偶数行的状态填入`f[0][j]`中，如下图

![img](https://staticcdn.boyuai.com/user-assets/5085/oGXg4Dv6cRGrn8AANYL5Je/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%985.jpg!jpg)

所以整个代码实现就变成了

```c++
// ...
int f[2][N]; // 相当于只开了两个一维数组
int main() {
    // 动态规划过程
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= V; ++j) {
        if (j < v[i]) 
            // i & 1是为了取i的奇偶性
            f[i & 1][j] = f[(i - 1) & 1][j];	
        else 
            f[i & 1][j] = max(f[(i - 1) & 1][j], f[(i - 1) & 1][j - v[i]] + p[i]);
        }
    } 
    
    // 输出
    cout << f[n & 1][V] << endl;
}
```



实现

```cpp
#include <bits/stdc++.h>
#define N 1002
using namespace std;

int n = 3; 
int V = 70;
int v[N] = {0, 71, 69, 1}; // 背包中共有3个物体，体积分别为71，60，1
int p[N] = {0, 100, 1, 2}; // 背包中共有3个物体，价值分别为100，1，2
int f[2][N]; // 相当于只开了两个一维数组

int main() {
    // 动态规划过程
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= V; ++j) {
        if (j < v[i]) 
            f[i & 1][j] = f[(i - 1) & 1][j];    // i & 1是为了取i的奇偶性
        else 
            f[i & 1][j] = max(f[(i - 1) & 1][j], f[(i - 1) & 1][j - v[i]] + p[i]);
        }
    } 
    
    // 输出
    cout << f[n & 1][V] << endl;
}
```





### 算法优化2 —— 优化到一维数组

那么我们可不可以再进一步优化空间，使得只用一个一维数组就能解决整个问题了呢？

想到之前“踩石头过河”的类比，我们可能会觉得不太可能。但是如果我们进一步分析整个表的填写，如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/VZGyic3nygX2otyKpSxfGB/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%986.jpg!jpg)

会发现下一行的某个状态，正好是由它上面的元素，以及左上方的某个元素转移而来。所以我们需要保证当计算黄色状态时上面两个绿色状态没有被覆盖掉。所以，当我们计算第i*i*行时，完全可以将$j$从大到小枚举，这样在计算状态$(i, j)$之前，数组$f[j]$中存储的是状态$f[i - 1, j]$，更新完以后，$f[j]$存的状态就是$f[i, j]$了。如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/pUCFyjjp8de3Lfs6J9egRN/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%987.jpg!jpg)

所以代码可以这样写：

```c++
// ...
int f[N];	// 相当于只开了一个一维数组
int main() {
    // 动态规划过程
    for (int i = 1; i <= n; ++i) {
        for (int j = V; j >= v[i]; --j) {	
            // 只枚举到v[i]，是因为在v[i]之前，所有f[i][j] = f[i - 1][j]
            // 那么在一维数组的场景下，就相当于没有改变
            f[j] = max(f[j], f[j - v[i]] + p[i]);
        }
    } 
    
    // 输出
    cout << f[V] << endl;
}
```





## 总结

- **背包问题**是一种经典的**动态规划**问题。

> 问题描述为有n个物品，每个物品有一定的体积和价值。我们想挑选一些物品放入容量为V的背包里，求最大价值。

- **背包问题**的分析方式是通过讨论每个物品“**放与不放**“，连接前$i-1$个物品的状态和前i*i*个物品的状态之间的关系。所以最终该状态的值就是两种选择下，获得收益的较大值。
- **背包问题**的**时间复杂度**和**空间复杂度**都是$O(nV)$，但是我们可以使用滚动数组，或者进一步精细分析，将**空间复杂度**下降为O(V)*O*(*V*)。
- **背包问题**中动态规划**四要素**：

1. **状态**：

> 用`f[i][j]`表示前$i$个物品，放在空间为$j$的背包里，能获得的最大收益。

1. **转移方程**：

> 因为每一个阶段有至多两种选择，所以需要分别计算两种选择的收益后取较大值。

```c++
// j < v[i]，表示装不下第i个物品
f[i][j] = f[i - 1][j];   
// otherwise
f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + p[i]);	
```

1. **初始状态**：

> 在一个物品都没放的时候，无论背包大小多少，总价值都是00，即

```c++
f[0][j] = 0; // 0 <= j <= V
```

1. **转移方向**：

> 观察转移方程，发现要想保证等式右边的状态一定比左边的状态先算出来，只需要保证$i$从小到大计算即可。

- **背包问题**代码实现：

```c++
#include <bits/stdc++.h>
#define N 1002
using namespace std;

int n, V, v[N], p[N];
int f[N][N]; 

int main() {
    // 输入
    cin >> V >> n;		// V是总体积，n是物品总个数
    for (int i = 1; i <= n; ++i) 
        cin >> v[i] >> p[i];
    
    // 动态规划
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= V; ++j) {
            if (j < v[i])  // 当前背包容量不够装第i个物品
                f[i][j] = f[i - 1][j];		
            else // otherwise
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + p[i]); 
        }
    } 
	
    // 输出
    cout << f[n][V] << endl;
    return 0;
}
```




## 练习

### 公路乘车

一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里数来付费。每辆汽车仅会行驶整数的公里数且最大不会超过10，行驶不同的公里数所需的金额也不同（注意这些金额并无实际的经济意义，即行驶10公里费用可能比行驶一公里少）。现在阿晓打算坐车行驶`n`公里，当然，可以随意通过无限次的换车来完成旅程，请你帮助算出完成旅程最少的费用。

输入描述：

第一行10个整数，分别表示行驶一公里到行驶十公里的所需费用。

第二行一个整数`n (n <= 100)`，表示需要行驶的里程数。

输出描述：

一行一个整数表示最少所需费用。

示例 1：

输入：

```
12 21 31 40 49 58 69 79 90 101
15
```

输出：

```
147
```


实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[20], f[101];

int main() {
    // 请补全代码，实现题目功能
    memset(f, 0x3f, sizeof(f));
    f[0] = 0;
    for (int i = 1; i <= 10; i++)
        cin >> a[i];
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 1; j <= 10; j++) {
            if (i + j > n)
                break;
            f[i + j] = min(f[i + j], f[i] + a[j]);
        }
    }
    cout << f[n];
    return 0;
}

```



### 采药

山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值，阿晓需要在有限的时间`T`内，采集尽可能高价值的草药。请你帮她算一算在时间限制内能采到的价值总和最高是多少。

输入描述：

第一行两个整数`T N`，分别表示限制的时间和草药的数量，其中`1 ≤ T ≤ 1000`，`1 ≤ N ≤ 100`。

接下来`N`行，每行两个整数`vi wi`，分别表示该草药所需的时间和它的价值，其中`1 ≤ vi wi ≤ 100`。

输出描述：

一个整数，表示价值的最大值。

示例 1：

输入：

```
70 3
71 100
68 1
1 2
```

输出：

```
3
```


实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int f[1010];

int main() {
    // 请补全代码，实现题目功能
    int n, t, v, w;
    cin >> n >> t;
    for (int k = 1; k <= t; k++) {
        cin >> v >> w;
        for (int i = n; i >= v; i--)
            f[i] = max(f[i], f[i - v] + w);
    }
    cout << f[n];
    
    return 0;
}

```



### 开心的金明

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第j件物品的价格为w[j]，重要度为v[j]，共选中了k件物品，编号依次为j1，j2，...，jk，则所求的总和为：

w[j1] * v[j1] + w[j2] * v[j2] + …+ w[jk] * v[jk]。（其中*为乘号）

请你帮助金明设计一个满足要求的购物单。

输入描述：

每组输入数据的第1行，为两个正整数，用一个空格隔开：

N m

（其中N（<30000）表示总钱数，m（<25）为希望购买物品的个数。）

从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数

w v

（其中w表示该物品的价格(w<=10000)，v表示该物品的重要度(1~5)）


输出描述：

每组输出只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<100000000）。

示例 1：

输入：

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

输出：

```
3900
```


实现

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int w[35],v[35],f[50005]; //w代表价格，v代表价值
int n,m;
int main()
{
    scanf("%d %d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d %d",&w[i],&v[i]); //输入每个商品的价格和价值
    }
  
    // TODO 请补全下述代码，完成题目
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=w[i];j--)
        {
            f[j]=max(f[j],f[j-w[i]]+w[i]*v[i]); //dp（状态转移方程）
        }
    }
  
    printf("%d",f[m]); //输出
    return 0;
} 

```




