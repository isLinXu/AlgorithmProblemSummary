# 二分查找方法

---

## 代码讲解

我们先来回顾一下**二分查找**的思路：我们设定一个初始的L和R，保证答案在`[L,R]`中，当`[L,R]`中不止有一个数字的时候，取区间的中点M，询问这个中点和答案的关系，来判断答案是M，还是位于`[L,M-1]`中，还是位于`[M+1,R]`中。一般**二分查找**的伪代码如下：

```cpp
int L = 区间左端点;
int R = 区间右端点;            // 闭区间
while( L < R ) {             // 区间内有至少两个数字
    int M = L + (R - L) / 2; // 求出区间中点
    if( M是答案 ) 答对啦;
    else if( M比答案小 ) L = M+1;
    else R = M-1;            // M比答案大
}
// 若运行到这里，因为答案一定存在，所以一定有L==R，且L是答案
```

### **数组上的二分查找**

在一个**排好序**的数组上找到第一个大于等于x的数字的位置（假设数组是从小到大排好序的）。

> 问题： 输入n，x，以及一个长度为n的数组a（已经从小到大排好序了）
>
> 输出数组a中最左边的大于等于x的数字的下标，数组下标从0开始
>
> 输入数字都是1000000000以内的非负整数。数组长度不超过50000。若数组中不存在大于等于x的数字，输出-1

比如你要在下面这个数组中找到第一个大于等于12的数字的位置，用二分查找应该怎么做呢？请先思考一下再进入下一步～

![img](https://staticcdn.boyuai.com/user-assets/5085/gL2NZ2eFVXxKnmXEurPbuV/1.png!png)



## 在升序的数组上进行二分查找

在一个**排好序**的数组上二分查找一个数字x，一般都可以变成如下的问题：在数组中找到第一个大于等于x的数字的位置（假设数组是从小到大排好序的）。

> 问题： 输入n，x，以及一个长度为n的数组a（已经从小到大排好序了）
>
> 输出数组a中最左边的大于等于x的数字的下标，数组下标从0开始
>
> 输入数字都是1000000000以内的非负整数。数组长度不超过50000。若数组中不存在大于等于x的数字，输出-1

首先，我们先来运行看看在升序的数组上进行二分查找算法的代码：

请运行右侧代码，填入不同输入观察一下上述问题的答案。特别注意输入格式：

> 输入样例：
>
> 9 4
>
> 2 3 3 3 3 4 4 4 4



实现

```cpp
#include <iostream>
using namespace std;

int n, x, a[100000];

int main() {
    cin >> n >> x;
    // 输入数组
    for( int i = 0; i < n; ++i ) 
        cin >> a[i];
    // 考虑数组中不存在大于等于x的数字的情况
    if( x > a[n-1] ) {           
        cout << -1 << endl;
        return 0;
    }
    
    // 二分查找
    int L = 0, R = n-1;          // 数组下标从0到n-1，闭区间
    while( L < R ) {             // 当区间中至少有两个数字的时候，需要继续二分
        int M = L + (R - L) / 2; // 求出区间中点
        if( a[M] < x ) {         // 答案一定出现在[M+1,R]中
            L = M+1;
        } else {                 // a[M] >= x，答案一定出现在[L,M]中
            R = M;
        }
    }
    
    // 此时L == R，a[L]就是第一个大于等于x的数字
    if ( a[L] == x) {
        cout << L << endl;  // 如果答案存在，则输出答案
    } else {
        cout << -1 << endl; // 如果答案不存在，则输出-1
    }
    
    return 0;
}
```



## 一些特殊情况

请手动模拟一下这段代码在下面数组上的运行过程，体会一下这段代码是如何处理一些边界情况的。

![img](https://staticcdn.boyuai.com/user-assets/5085/gL2NZ2eFVXxKnmXEurPbuV/1.png!png)

- 比如：答案不存在的情况我们是如何处理的？
- 比如：当区间内只有两个数字的时候，这段代码还能正常运行吗？
- 比如：数组中有很多个重复元素的时候，这段代码还能正常运行吗？
- 比如：为什么循环结束之后一定有`L == R`？为什么不会出现`L > R`的情况？

请自己写一些简单情况出来，并手动模拟运行这段代码，想一想为什么这段代码不会出错。

- 比如：在`2 3`这个数组中找到第一个大于等于3的元素。
- 比如：在`2 3 3 3 3 4 4 4 4`这个数组中找到第一个大于等于4的元素。



## 代码实现 —— 在升序的数组上进行二分查找

在一个**排好序**的数组上找到第一个大于等于x的数字的位置（假设数组是从小到大排好序的）。

> 问题： 输入n，x，以及一个长度为n的数组a（已经从小到大排好序了）
>
> 输出数组a中最左边的大于等于x的数字的下标，数组下标从0开始
>
> 输入数字都是1000000000以内的非负整数。数组长度不超过50000。若数组中不存在大于等于x的数字，输出-1

首先，我们来看看在升序的数组上进行二分查找算法的伪代码：

```cpp
int L = 0;
int R = n-1;                // 数组下标从0到n-1，闭区间
while( L < R ) {            // 区间内有至少两个数字
    int M = L+(R-L)/2;      // 求出区间中点
    if( M比答案小 ) L = M+1; // 答案一定出现在[M+1,R]中
    else R = M;             // a[M] >= x，答案一定出现在[L,M]中
}
// 此时L == R，a[L]就是第一个大于等于x的数字
```

完整实现

```cpp
#include <iostream>
using namespace std;

int n = 9;
int x = 4;
int a[10] = {2, 3, 3, 3, 3, 4, 4, 4, 4};

int main() {

    // 考虑数组中不存在大于等于x的数字的情况
    if( x > a[n-1] ) {           
        cout << -1 << endl;
        return 0;
    }
    
    // TODO 请补全二分查找的代码
    // 二分查找
    int L = 0, R = n-1;          // 数组下标从0到n-1，闭区间
    while( L < R ) {             // 当区间中至少有两个数字的时候，需要继续二分
        int M = L + (R - L) / 2; // 求出区间中点
        if( a[M] < x ) {         // 答案一定出现在[M+1,R]中
            L = M+1;
        } else {                 // a[M] >= x，答案一定出现在[L,M]中
            R = M;
        }
    }
    
    // 此时L == R，a[L]就是第一个大于等于x的数字
    if ( a[L] == x) {
        cout << L << endl;  // 如果答案存在，则输出答案
    } else {
        cout << -1 << endl; // 如果答案不存在，则输出-1
    }
    
    return 0;
}
```





## 倒过来怎么做

那现在，如果你面临一个新的问题：

- 有一个**从小到大排好序**的数组，你要找到**从右向左数**第一个小于等于x的数字，应该怎么做？

> 问题：输入n，x，以及一个长度为n的数组a（已经从小到大排好序了）
>
> 输入样例：
>
> 9 4
>
> 2 3 3 3 3 4 4 4 4

应该这样修改程序？比如，这样：

```cpp
int L = n-1, R = 0; // ???太迷惑了
```

很多小白可能会写出`L = n-1, R = 0`的初始条件（因为我们是从右向左数），然后比葫芦画瓢找到第一个小于等于x的数字。但是这样做太令人迷惑了，直觉上我们都觉得应该是`L < R`或者`low < high`，但是有些问题的“可行区间左端点”会比“可行区间右端点”要大，于是就会出现上面这段迷惑的代码。

显然，这样做会给我们思考带来很大的阻碍，这样是不符合直觉的，在写一些边界条件的式子的时候更可能出现错误。其实，我们往往可以通过问题转化，在写代码的时候把条件转化为`L < R`。比如在这个例子中，我们可以把问题转化为“找到从左往右数**最后一个**小于等于x的数字”，这时候就可以写出`L = 0, R = n-1`这样的初始条件。

**通用做法**

有些复杂的问题，进行问题转换也是较为困难的，因此我们需要总结出一个不费脑子、不需要思考就可以写出优美代码的做法。

我们注意到，二分查找的精髓在于，只通过`a[M]`的值来判断：答案是在左半边还是在右半边。

因此，我们只要抛弃传统意义上的“大小”概念，牢牢抓住这一点进行分析，仔细推断出这个条件用到的表达式，就一定可以写出优美的代码。

伪代码如下：

```cpp
while( L < R ) {
    int M = L + (R - L)/2;
    if( 答案在[M + 1,R]中 ) { // 思考一下，什么情况下能够说明“答案在[M + 1,R]中”
        L = M + 1;
    } else { // 答案在[L,M]中
        R = M;
    }
}
```



实现

```cpp
#include <iostream>
using namespace std;

int n = 9;
int x = 4;
int a[10] = {2, 3, 3, 3, 3, 4, 4, 4, 4};

int main() {

    // 考虑数组中不存在大于等于x的数字的情况
    if( x > a[n-1] ) {           
        cout << -1 << endl;
        return 0;
    }
    
    // TODO 请补全二分查找的代码
    // 二分查找
    int L = 0, R = n-1;          // 数组下标从0到n-1，闭区间
    while( L < R ) {             // 当区间中至少有两个数字的时候，需要继续二分
        int M = L + (R - L) / 2; // 求出区间中点
        if( a[M] <= x ) {        // 答案一定出现在[M+1,R]中
            L = M+1;
        } else {                 // a[M] >= x，答案一定出现在[L,M]中
            R = M;
        }
    }
    
    // 此时L == R，a[L]就是第一个大于等于x的数字
    if ( a[L] == x) {
        cout << L << endl;  // 如果答案存在，则输出答案
    } else {
        cout << -1 << endl; // 如果答案不存在，则输出-1
    }  
    
    
     // 此时L == R，a[L]就是第一个大于等于x的数字
    if ( a[L] == x) {
        cout << L << endl;  // 如果答案存在，则输出答案
    } else {
        cout << -1 << endl; // 如果答案不存在，则输出-1
    }   
        return 0;
}
```







## 糟糕！死循环！

但是！假设现在有`L = 3, R = 4`，你要找的是最后一个小于等于`x = 100`的数字，并且数组元素是`a[3] = 80, a[4] = 90`。

然后通过计算得到中点`M = 3`，检查发现`a[3] <= 100`，所以执行`L = M`，把答案的可行区间变成`[M,R]`。

你已经发现问题了！在经过一次二分之后，变量仍然保持了`L = 3, R = 4`没有变化，循环条件`L < R`一直被满足，我们始终无法结束循环。

这就让我们的程序进入了**死循环**！





## “差一点”问题（off-by-one）

**为什么会死循环？**

如果你实现了刚刚问题（有一个从小到大排好序的数组，你需要找到从左往右数最后一个小于等于x的数字）的代码，你可能会写出下面这样的代码。

```cpp
int L = 0, R = n-1;
while( L < R ) {
    int M = L + (R - L)/2;
    if( a[M] <= x ) { // 答案一定在[M,R]中
        L = M;
    } else { // 答案一定在[L,M - 1]中
        R = M - 1;
    }
}
// a[L]就是答案
```

但是你发现，这个程序好像存在一些问题：有时候，程序会陷入死循环，无法得到运行结果。这是为什么呢？

和最初的问题对比一下，你能发现这两份代码的不同之处吗：

```cpp
// 最初的问题：在数组中找到从左往右 第一个 大于等于x的数字的位置
if( 答案在[M + 1,R]中 ) {
    L = M + 1;
} else {
    R = M; // 这里可能引发“差一点”问题
}
// 现在的问题：在数组中找到从左往右数 最后一个 小于等于x的数字
if( 答案在[M, R]中 ) {
    L = M;
} else {
    R = M - 1;
}
```

这段代码在逻辑上肯定是没有错误的 —— 你每次都把正确的区间挑选出来了。那为什么这段代码会在某些时候引起死循环呢？

**如何避免问题**

事实上，死循环只会在刚刚这种况出现：

> 假设现在有`L = 3, R = 4`，你要找的是最后一个小于等于`x = 100`的数字，并且数组元素是`a[3] = 80, a[4] = 90`。
>
> 然后通过计算得到中点`M = 3`，检查发现`a[3] <= 100`，所以执行`L = M`，把答案的可行区间变成`[M, R]`。
>
> 在经过一次二分之后，变量仍然保持了`L = 3, R = 4`没有变化，循环条件`L < R`一直被满足，我们始终无法结束循环。

这是因为我们在判断出答案在`[M, R]`中的时候，执行了`L = M`这句话，而根据我们的中点计算公式`M = L + (R - L)/2`，我们在`R == L+1`的情况下总会得到`L == M`。所以我们在经过一次二分之后，`L`和`R`的值没有发生变化，也就陷入了死循环。

要避免这个问题，其实也非常简单，我们只需要把中点计算公式变成`M = L + (R - L + 1)/2`即可。在之前的中点计算公式`M = L + (R - L)/2`中，我们如果遇到了中点不是整数的情况，则会把中点向下取整，因此在出现`L + 1 == R`这种情况的时候就会始终有`L == M`从而引发问题。现在我们通过一个`+1`使得在中点不是整数的时候把中点**向上取整**，就可以避免这个问题（请在纸上模拟代码的运行过程，以体会这个公式是如何解决“差一点”问题的）。





## “一点”都不差

但是！当我们使用`M = L +(R - L + 1)/2`作为中点计算公式的时候，就会在最初的代码（在数组中找到第一个大于等于x的数字的位置）上遇到“差一点”问题。

```cpp
// 在数组中找到从左往右大于等于x的数字的位置
if( 答案在[M + 1,R]中 ) {
    L = M + 1;
} else {
    R = M; // 这里可能引发“差一点”问题
}
```

建议你记住下述规律：

- 如果代码中是用的`L = M`，把`L`不断往右push，那么`M`向上取整（`M = L + (R - L + 1)/2`）；
- 如果代码中是用的`R = M`，把`R`不断往左push，那么`M`向下取整（`M = L + (R - L)/2`）。





## 总结

二分查找可能会遇到哪些边界情况？为什么示例代码能完美的解决这些边界情况？

答：总是可以通过问题转换写出满足`L < R`的优美代码。

- 二分查找伪代码

```cpp
while( L < R ) {
    int M = L + (R - L)/2;
    if( 答案在[M + 1,R]中 ) { // 思考一下，什么情况下能够说明“答案在[M+1,R]中”
        L = M + 1;
    } else { // 答案在[L,M]中
        R = M;
    }
}
```

- 写二分查找遇到了死循环，考虑是不是遇到了“差一点”问题。

  - 如果代码中是用的`L = M`，把`L`不断往右push，那么`M`向上取整（`M = L + (R - L + 1)/2`）；
  - 如果代码中是用的`R = M`，把`R`不断往左push，那么`M`向下取整（`M = L + (R - L)/2`）。

- 代码示例：

  - 有一个**从小到大排好序**的数组，你要找到第一个大于等于x的数字，应该怎么做？

  > 输入n，x，以及一个长度为n的数组a（已经从小到大排好序了）
  >
  > 输入样例：
  >
  > 9 4
  >
  > 2 3 3 3 3 4 4 4 4

  - 代码样例：

```cpp
#include <iostream>
using namespace std;

int n, x, a[100000];

int main() {
    cin >> n >> x; // n为数组元素个数，x为
    // 输入数组
    for( int i = 0; i < n; ++i ) 
        cin >> a[i];
    // 考虑数组中不存在大于等于x的数字的情况
    if( x > a[n-1] ) {           
        cout << -1 << endl;
        return 0;
    }
    
    // 二分查找
    int L = 0, R = n-1;          // 数组下标从0到n-1，闭区间
    while( L < R ) {             // 当区间中至少有两个数字的时候，需要继续二分
        int M = L + (R - L) / 2; // 求出区间中点
        if( a[M] < x ) {         // 答案一定出现在[M+1,R]中
            L = M + 1;
        } else {                 // a[M] >= x，答案一定出现在[L,M]中
            R = M;
        }
    }
    // 此时L == R，a[L]就是第一个大于等于x的数字
    if ( a[L] == x) {
        cout << L << endl;  // 如果答案存在，则输出答案
    } else {
        cout << -1 << endl; // 如果答案不存在，则输出-1
    }
    return 0;
}
```

- 最后，再回顾一下在上一知识点中，我们推导了**二分查找**的时间复杂度。只有当我们询问区间中点的时候，我们才能让可行区间的长度以最快的速度变短——每次大约变为原来长度的一半，所以**二分查找**的时间复杂度是$log_2(n)$。

  > **二分查找**时间复杂度的计算方法：
  >
  > 比如，在猜数字的游戏中，假设我们一开始有n个数字。每次把剩余数字的区间分成两半，直到x*x*次后只剩下最后一个数字，就是我们想要的答案啦。 计算公式如下：
  >
  > $n * 1/(2^x) = 1$
  > x次后只剩下最后一个数字
  >
  > $x = log_2(n)$
  >
  > 那么，x的值就是$log_2(n)$咯



## 练习

### 二分查找

给定一个长度为`n (1 ≤ n ≤ 10000)`且由小到大排序的序列，查找数字`x`在该序列中的位置。

输入描述：

第一行一个整数`n`，表示该序列的长度。

接下来`n`行，每行一个整数，表示该序列。

最后一行一个整数`x`，表示要查询的数字。

输出描述：

一行，若`x`存在，则输出x是从左向右第几个；若不存在，则输出`not find`。

示例 1：

输入：

```
5
1
2
3
4
5
3
```

输出：

```
3
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[100010];

int main() {
    // 请补全代码，实现题目功能
    int n, x;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    cin >> x;
    int pos = lower_bound(a + 1, a + n + 1, x) - a;
    if (a[pos] != x)
        cout << "not find" << endl;
    else
        cout << pos << endl;
    return 0;
}
```














