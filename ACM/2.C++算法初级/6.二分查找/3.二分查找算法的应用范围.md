# 二分查找算法的应用范围

---

## 应用范围

**有序才能二分查找**

如果我们想要在一个数组上进行二分查找，那么这个数组必须是**有序**的，不管是升序还是降序，它必须是有序的。为什么呢？

注意二分查找的本质是什么：通过比较数组中间那个值和我们要求的值的关系，来判断出“答案不可能出现在数组的某一半”，从而让我们的查找范围缩小为原来的一半。

![img](https://staticcdn.boyuai.com/user-assets/5085/XnKc61PZ1UP2ijVRj3Fsz5/1.png!png)

这也就是为什么我们要求数组中的元素是满足**单调性**的：只有这样，我们才能保证当`a[M]`不满足条件的时候，它左边（或者右边）的所有元素都不满足条件。

比如，我们要在一个升序的数组中找到第一个大于等于12的数字：

![img](https://staticcdn.boyuai.com/user-assets/5085/iVeXY5sj9j1dn7qcAh6Tza/a1.png!png)

而我们在某次二分中发现`a[M] = 7`，由于数组是升序的，我们就可以判断出12一定出现在`a[M]`的右边。如果数组是乱序的，我们就无法得到任何有用的信息。

那么是不是任何有序的数据结构都可以应用二分查找算法呢？



## 其他有序结构

**日期**

日期是一个天然有序的结构：我们可以定义日期A小于日期B意为：在日历上A排在B的前面。比较两个日期的大小也可以通过很简单的方式进行：先比较年，再比较月，最后比较日。

```cpp
struct Date {
    int year, month, day;
};
bool operator<( const Date &a, const Date &b ) {
    if( a.year == b.year ) {
        if( a.month == b.month ) {
            return a.day < b.day;
        } else {
            return a.month < b.month;
        }
    } else {
        return a.year < b.year;
    }
}
```

看起来只是一组三维数据而已，和二维数据的处理没什么差别？

但是我们可能会面临一个问题：如果我们要在公元1年1月1日和1000000000年1月1日之间二分，我们该如何求出两个日期的中点呢？

我们把日期表示成`YYYYMMDD`的形式，比如公元1年1月1日就是00010101，1000000000年1月1日就是10000000000101。则两个日期的中点，就是两个数字的中点，只不过我们需要把这个数字向下取整（或者向上取整）到最近的合法的日期。

比如，我们要求`19701212`和`20200817`的中点，我们可以直接求`(19701212 + 20200827) / 2 = 19951019`，这就是这两个日期的近似中点。如果我们得到了类似于`19971805`这样不合法的日期（没有18月），我们只需要把18月向下取整到合法的日期（12月），变为`19971205`即可。

**字符串**

字符串也是一个天然有序的数据结构：[字典序](https://baike.baidu.com/item/字典序/7786229)就是字符串的大小顺序。因此我们可以给一堆字符串按照字典序排序。

```cpp
string s[100];
for( int i = 0; i < n; ++i )
    cin >> s[i];
// sort函数用于给数组中的元素排序
sort(s, s+n); // string类的比较函数为比较两个字符串的字典序
```

现在在一堆排好序的字符串中，我们要找出所有前缀是`com`的字符串，应该怎么做呢？

```
apple
awsl
bag
bed
comm
commute
compare
cooperate
```

容易发现，所有前缀是`com`的字符串，在数组中也是一个连续的区间。

我们可以把数组中的所有字符串截断到前3位，然后使用二分查找法找到第一个`com`出现的位置和最后一个`com`出现的位置。

在这之间的所有字符串，前缀都是`com`。

**二维数据**

有的时候我们需要用到二维数据，比如平面中的点，就需要两个数字来表示，再比如`std::pair`这个数据结构，就是简单地把两个数字组合在一起。

不妨假设我们遇到的二维数据都是下面这样子的。类似平面上的整数点，一个点用两个整数`(x,y)`表示。

```cpp
struct Point {
    int x, y;
};
// 这是运算符重载，当我们在代码中用小于号比较两个Point类变量的时候，就会用这个函数进行比较
bool operator<( const Point &a, const Point &b ) { // 如何定义a < b
    if( a.x == b.x ) {
        return a.y < b.y;
    } else {
        return a.x < b.x;
    }
}
```

这里我们定义了一种常用的比较二维数据的方法：首先比较两个数据的第一维，数字小的排在前面，当第一维数字相同的时候，比较第二维，数字小的排在前面。比如`(3,3) < (4,2)`，因为先比较第一维`3 < 4`。再比如`(2,3) < (2,5)`，因为第一维相同时比较第二维。

如果我们有一个排好序的`Point`数组，我们想找到数组中所有`x = 5`的元素（容易发现所有`x = 5`的元素在数组中一定是一个连续的区间），应该怎么做呢？

一个排好序的`Point`数组例子：`(1,2), (2,3), (2,4), (5,-1), (5,2), (5,5), (7,4)`。

```cpp
Point a[100000];
for( int i = 0; i < n; ++i )
    cin >> a[i].x >> a[i].y;
sort(a, a+n); // sort函数可以给数组中的元素排序
```

我们只需要两次二分查找就可以了：分别找到**第一个大于等于**`Point(5, INT_MIN)`的元素，以及**最后一个小于等于**`Point(5, INT_MAX)`的元素。这两个元素中间的所有元素就是`x = 5`的所有元素（闭区间）。`INT_MIN`和`INT_MAX`分别是`int`所能表达的最小值和最大值。


## 总结

如果我们想要在一个数组上进行二分查找，那么这个数组必须是**有序**的，不管是升序还是降序，它必须是有序的。

为什么呢？

注意二分查找的本质是什么：通过比较数组中间那个值和我们要求的值的关系，来判断出“答案不可能出现在数组的某一半”，从而让我们的查找范围缩小为原来的一半。

![img](https://staticcdn.boyuai.com/user-assets/5085/XnKc61PZ1UP2ijVRj3Fsz5/1.png!png)

这也就是为什么我们要求数组中的元素是满足**单调性**的：只有这样，我们才能保证当`a[M]`不满足条件的时候，它左边（或者右边）的所有元素都不满足条件。


所以：

- 要进行二分，数组必须是有序的。
- 基本上所有可以比较的数据都可以进行二分查找。
  - 比如：日期、字符串、二维数组
- 如果数据可以方便的计算“中点”，那么就可以在大区间上二分查找指定的数据（比如日期）