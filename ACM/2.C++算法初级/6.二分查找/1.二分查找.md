# 二分查找

---

## 猜数游戏

你正在参加一个电视节目，主持人邀请你上台玩一个游戏：主持人在心中想一个`[1,1000]`范围内的整数，你需要用尽量少的询问猜出这个数是什么。你可以询问主持人“这个数是x吗？”，主持人会告诉你，他心中所想的数是大于x，还是小于x，还是恰好等于x。

举个例子，假如主持人心中所想的数字是250，你可以先问主持人“你想的这个数是1吗？”。然后你会得到“这个数大于1”的回答。接下来你可以继续问“这个数是2吗？”。你又会得到“这个数大于2”的回答……你每次询问的数字都比之前的数字大1，这样当你询问到第250次的时候，主持人就会告诉你“我想的数字就是250”。你就得到了正确答案。

![img](https://staticcdn.boyuai.com/user-assets/5085/kZqU1KutweQ4fiEYn4RzYH/1.png!png)

当然，这样的策略肯定是很差的。那么，用什么样的策略进行游戏，才能让你尽快得到正确答案呢？或者，更严谨的说，用什么样的策略进行游戏，才能在最差的情况下用最少的询问次数得到正确答案呢？请先思考思考吧~




## 猜数游戏的策略——二分查找

### **一个优秀的例子**

从数字1开始慢慢地一个一个地问实在是比较笨，我们不难想到一些方法：询问100、200、300、400……来确定答案位于哪个区间内，然后在这个区间内故技重施（假设答案在300和400之间），询问310、320、330、340……来缩小这个区间。当这个区间足够小的时候，我们再对区间中的每个数字挨个询问。

实际上，每次询问当前区间的中点是最优的策略。我们根据主持人的回答来确定最终答案是位于哪半边区间里面。由于我们每次会把当前区间的长度大约除以2，因此我们在大约10次询问之后，就一定能知道最终答案。下面这个游戏记录就展示了这个策略。

![img](https://staticcdn.boyuai.com/user-assets/5085/x5Gyy2PFgwJVvxghdxhfK1/2.png!png)

如何用程序语言描述这样一个策略？为什么这种策略是最好的呢？请先思考思考~

**通用的游戏策略**

用伪代码描述这样一个策略，就是下面这段：

```cpp
int L = 区间左端点;
int R = 区间右端点; // 闭区间
while( L < R ) { // 区间内有至少两个数字
    int M = L+(R-L)/2; // 区间中点
    if( M是答案 ) 答对啦;
    else if( M比答案小 ) L = M+1;
    else R = M-1; // M比答案大
}
// 若运行到这里，因为答案一定存在，所以一定有L==R，且L是答案
```

这也是所谓**二分查找**的思路：我们设定一个初始的L和R，保证答案在`[L,R]`中，当`[L,R]`中不止有一个数字的时候，取区间的中点M，询问这个中点和答案的关系，来判断答案是M，还是位于`[L,M-1]`中，还是位于`[M+1,R]`中。

这里有一个[二分查找的可视化过程](https://www.cs.usfca.edu/~galles/visualization/Search.html)，你可以进入网站体验一下**二分查找**的步骤过程。

虽然**二分查找**的方法能够帮助我们快速找到答案，但我们还有很多很多的细节问题没有处理，比如：

- 如果循环最后因为不满足`L < R`条件而退出，这时候L和R到底是什么关系？答案是什么？
- 如果答案不存在会怎么样？

我们暂时并不需要考虑这些问题，因为我们现在的目标是“理解**二分查找**的思路，并学会手算**二分查找**”。既然是手算，那么当区间内剩余的数字个数寥寥无几的时候，我们只要挨个询问一遍就行了，这并不影响**二分查找**的复杂度。





### **为什么要用这种策略？**

为什么**二分查找**的方法是最优的呢？

回顾我们刚刚讲到的“最优”的定义：在最差的情况下，我们进行询问的次数最少。

而这个猜数游戏的本质是什么？我们每进行一次询问，就可以排除一些错误答案。

![img](https://staticcdn.boyuai.com/user-assets/5085/7CdJaKypoN3sNwFqQmZHWD/3.png!png)

如图，当我们询问M位置的时候，主持人告诉我们的信息实际上帮助我们排除了一部分错误答案，从而缩小正确答案所在的区间长度。

因此，在最差的情况下，如果我们询问的位置不是区间的中点，那么主持人帮我们排除掉的区间一定是长度较短的那部分。

所以，只有当我们询问区间中点的时候，我们才能让可行区间的长度以最快的速度变短——每次大约变为原来长度的一半，所以**二分查找**的时间复杂度是$log_2(n)$。

> **二分查找**时间复杂度的计算方法：

> 比如，在猜数字的游戏中，假设我们一开始有n个数字。每次把剩余数字的区间分成两半，直到x*x*次后只剩下最后一个数字，就是我们想要的答案啦。 计算公式如下：

> $n * 1/(2^x) = 1$
> x*x*次后只剩下最后一个数字

> $x = log_2(n)$
> 那么，x的值就是log n咯

这就是为什么二分查找方法是最快的方法。




### 数组上的二分查找

现在，让我们从游戏回到编程问题。

首先，来看一个**二分查找**问题的最经典的应用：

你有一个长度为n的**排好序**的数组a，你需要在log_2(n)*l**o**g*2(*n*)的时间复杂度内求出数组a中第一个大于等于x的元素是多少，或者输出“数组a中不存在大于等于x的元素”。

我们现在并不要求写出通用代码，只要会手算**二分查找**即可，因此我们用下面这个数组作为例子，一步一步地来看看二分查找算法是如何运行的。

因为数组是排好序的，所以我们可以直接根据最后一个数来判断“数组中是否存在大于等于x的元素”。现在我们假设`x = 12`，需要在下面这个数组中用**二分查找**法找到第一个大于等于12的元素。

![img](https://staticcdn.boyuai.com/user-assets/5085/4t6hT7h5AA1ucgQYNXCdSh/4.png!png)

1、最开始有`L = 0, R = 9, M = 4`，我们检查`a[M]`和12的关系，发现`a[M] < 12`，因此符合条件的数字一定在`a[M+1]`到`a[R]`这些数中，所以令`L = M+1`，继续进行二分查找。

![img](https://staticcdn.boyuai.com/user-assets/5085/BowJPM2Xco5v55tsBzkcmu/5.png!png) ![img](https://staticcdn.boyuai.com/user-assets/5085/hGWpM7LgdG1bhzFEkvKc4L/6.png!png)

2、现在有`L = 5, R = 9, M = 7`，我们发现`a[M] >= 12`，因此符合条件的数字一定在`a[L]`到`a[M]`这些数字中，所以令`R = M`（注意不是`R = M-1`），继续进行二分查找。

> 那么，这里为什么令`R = M`而不是`R = M-1`呢？ 这是因为`a[M]`也可能是答案，因为我们要找的是第一个大于等于12的数字，所以`a[M]`不能被排除在外。

![img](https://staticcdn.boyuai.com/user-assets/5085/D8TWc2fZUhjDaMjJ41fseT/7.png!png)

3、现在有`L = 5, R = 7, M = 6`，我们重复刚才的步骤，发现`a[M] >= 12`，于是令`R = M`，继续进行二分查找。

![img](https://staticcdn.boyuai.com/user-assets/5085/afgm4dEmi5bWcBoXp8PRGR/8.png!png)

4、此时有`L = 5, R = 6, M = 5`，我们发现`a[M] >= 12`，于是继续令`R = M`。

![img](https://staticcdn.boyuai.com/user-assets/5085/VVo78kCcTuwXBq3QkV8S58/9.png!png)

5、最后，这时候已经有`L = R`了，这意味着`a[L] = 13`就是我们要找的答案咯。



## 总结

现在我们来看一下**二分查找**这个神奇的算法：

- **二分查找**的原理：每次排除掉一半答案，使可能的答案区间快速缩小。
- **二分查找**的时间复杂度：log_2(n)*l**o**g*2(*n*)，因为每次询问会使可行区间的长度变为原来的一半。
- 我们再来看一下**二分查找**的思路：我们设定一个初始的L和R，保证答案在`[L,R]`中，当`[L,R]`中不止有一个数字的时候，取区间的中点M，询问这个中点和答案的关系，来判断答案是M，还是位于`[L,M-1]`中，还是位于`[M+1,R]`中。**二分查找**的伪代码如下：

```cpp
int L = 区间左端点;
int R = 区间右端点; // 闭区间
while( L < R ) { // 区间内有至少两个数字
    int M = L+(R-L)/2; // 区间中点
    if( M是答案 ) 答对啦;
    else if( M比答案小 ) L = M+1;
    else R = M-1; // M比答案大
}
// 若运行到这里，因为答案一定存在，所以一定有L==R，且L是答案
```

正如之前说的，**二分查找**中其实还有很多细节问题没有处理，比如：

- 如果循环最后因为不满足`L < R`条件而退出，这时候L和R到底是什么关系？答案是什么？
- 如果答案不存在会怎么样？

但没有关系，这些问题在后面的课程中，我们会一一来解决的













