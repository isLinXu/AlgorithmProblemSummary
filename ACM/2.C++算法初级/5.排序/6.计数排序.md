# 计数排序

---

## 基本思想

如果给出下面100个数字，要求用肉眼给它们排序。

```
17, 88, 21, 73, 80, 10, 71, 73, 40, 50
98, 3, 100, 82, 71, 86, 65, 2, 68, 23
81, 6, 43, 35, 3, 75, 14, 81, 12, 34
90, 10, 12, 42, 88, 61, 61, 72, 43, 23
41, 71, 31, 13, 63, 72, 72, 18, 50, 32
82, 21, 97, 62, 28, 2, 78, 88, 77, 29
10, 44, 70, 59, 79, 55, 31, 96, 1, 47
32, 20, 70, 18, 79, 87, 80, 59, 58, 13
47, 55, 23, 12, 38, 7, 92, 5, 82, 97
91, 90, 29, 16, 66, 42, 18, 77, 16, 42
```

这一定是个比较困难的问题。

但如果这100个数字长成下面这个样子：

```
1, 0, 1, 0, 1, 0, 1, 1, 1, 0
1, 0, 1, 0, 1, 0, 1, 0, 1, 0
0, 0, 0, 0, 1, 1, 0, 1, 0, 0
1, 0, 0, 1, 0, 1, 0, 1, 1, 0
0, 0, 1, 0, 1, 0, 1, 0, 1, 1
1, 0, 1, 1, 1, 1, 0, 1, 0, 1
1, 0, 1, 0, 0, 1, 0, 0, 0, 1
1, 1, 1, 0, 0, 1, 0, 1, 1, 0
0, 0, 0, 1, 1, 1, 0, 1, 0, 1
1, 1, 1, 0, 0, 1, 0, 0, 1, 1
```

我们会发现这100个数字只有`0`和`1`两种情况，而假设要求将该序列从小到大排序，那么序列中的`0`一定会出现在`1`的前面。所以我们只需要统计0的个数和1的个数（假设有`a`个`0`和`b`个`1`），在写答案时，先写`a`个`0`，再写`b`个`1`即可。

上面的例子体现了**计数排序**的基本思想：

> 假设我们已知在待排序的序列中，值都是整数并且出现在一个很小的范围内，例如`[0..1000]`。那么，我们可以通过：
>
> 1. **分别统计每一种可能的值在序列中出现的次数**。
> 2. 从小到大（假设要求将序列从小到大排序）枚举所有值，**按照出现次数输出对应个数**。
>
> 来完成排序过程。



## 计数排序算法描述

给定长度为`n`的序列，假设已知序列元素的范围都是`[0..K]`中的整数，并且`K`的范围比较小（例如1$0^6$，开长度为$10^6$左右的`int`类型数组所占用的内存空间只有不到4M）。解决该问题的计数排序算法描述如下：

1. 使用整数数组`cnt`统计`[1..K]`范围内所有数字在序列中出现的个数。
2. 使用变量`i`枚举`1`到`K`，如果`i`出现了`cnt[i]`次，那么在答案序列的末尾添加`cnt[i]`个`i`。

下图是一个`n=6, K=3`的例子：

![img](https://staticcdn.boyuai.com/user-assets/5085/P3cwpbgAC1T71Tp4VF4tvU/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F1.jpg!jpg)

值得一提的是，如果元素的范围可以被很容易转换到`[0..K]`，我们也可以使用计数排序。如果元素范围是`[A..B]`，我们可以通过简单的平移关系将其对应到`[0..B-A]`上。或者所有数值均为绝对值不超过100的两位小数，那么我们可以通过将所有数字放大100倍将其转换为整数。



找出原序列中元素在答案中的位置

在有些场景中，比如我们根据`(key, value)`中的`key`关键字进行排序，**如果只是使用上面的计数排序，我们无法将`value`放到相应的`key`在答案序列中的对应位置中**。但是，如果我们可以将原序列和答案序列元素的位置对应求出来，那么这个问题就能得到解决。

![img](https://staticcdn.boyuai.com/user-assets/5085/SuFtuxMW6j4LjYCb6K9kPf/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F4.jpg!jpg)

试想，对于原序列中的数字x*x*，它排序后的位置可能出现在哪里呢？

因为在排序后的序列中，假设x*x*第一次出现的位置是`i`，最后一次出现的位置是`j`，那么`i`之前的元素一定比x*x*小，`j`出现的位置之后的元素一定比x*x*大。假设原序列中<x元素的个数是A，$\le x$≤的元素个数是B，那么x可能出现的位置一定是`[(A+1)..B]`！

**sum数组的求法和意义**

那么，我们怎样求出`A`和`B`呢？假设我们对`cnt`数组求前缀和，如下图所示，`cnt`数组元素求前缀和后为`sum`数组：

![img](https://staticcdn.boyuai.com/user-assets/5085/j9YRemFdZV5q5uF4SdRwyN/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F5.jpg!jpg)

这里，我们指出**`sum`数组的意义**：对于一个序列中可能出现的值`x`，`sum[x]`的含义是“小于等于`x`的数字个数”，同时，也可以看作指向答案序列中最后一个`x`出现的位置的指针。

**利用`sum`数组分配位置**

所以对于值`x`，A*A*即为`sum[x - 1]`，B*B* 即为`sum[x]`，`x`出现的排名为`[(sum[x - 1] + 1)..sum[x]]`，等价于`[(sum[x] - cnt[x] + 1)..sum[x]]`。我们将`sum`数组的位置标出来：

![img](https://staticcdn.boyuai.com/user-assets/5085/wYfgdhoW2tSWPBBJrC1CaV/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F6.jpg!jpg)

然后我们从后往前扫描每个元素，把它填到当前的`sum`对应值指向的格子中，并把`sum`向前移动。如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/9WzKgJYLxJaLkVfFkX5C7J/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F7.jpg!jpg)

有了原序列和答案序列的位置对应，我们也可以据此将对应元素放入答案数组中。所以该版本的计数排序算法描述如下：

> 1. 统计原序列中每个值的出现次数，记为`cnt`数组。
> 2. 从小到大枚举值的范围，对`cnt`数组求前缀和，记为`sum`数组。
> 3. 从后往前枚举每个元素`a[i]`，分配其在答案中的位置`idx[i]`为当前的`sum[a[i]]`，也就是将其放在所有值等于`a[i]`中的最后一个。并且将`sum[a[i]]`减少`1`，保证下次再遍历到同样的值时，它分配的位置正好在`idx[i]`前面一个。

基于分治法的排序算法基本流程如下：

## 代码实现 —— 计数排序1

首先，我们再来看一下**计数排序**的算法描述：

> 1. 统计原序列中每个值的出现次数，记为`cnt`数组。
> 2. 从小到大枚举值的范围，对`cnt`数组求前缀和，记为`sum`数组。
> 3. 从后往前枚举每个元素`a[i]`，分配其在答案中的位置`idx[i]`为当前的`sum[a[i]]`，也就是将其放在所有值等于`a[i]`中的最后一个。并且将`sum[a[i]]`减少`1`，保证下次再遍历到同样的值时，它分配的位置正好在`idx[i]`前面一个。

### 计数排序代码实现

下面我们给出计数排序的简单实现：

```c++
#include <bits/stdc++.h>
#define N 1000005
#define K 1000001    // 假设非负整数最大元素范围为1000000
using namespace std;
int a[N], n, b[N];
int cnt[K];
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        ++cnt[a[i]];    // 这里通过计数数组cnt来维护每一种值出现的次数
    }
    
    // 维护最终有序序列
    for (int i = 0, j = 0; i < K; ++i)      // 枚举每一种值i，指针j用来枚举填充答案数组中的位置
        for (int k = 1; k <= cnt[i]; ++k)   // 根据该值出现的次数
            b[++j] = i;                     // 添加对应个数的i到答案序列
	
    // 输出
    for (int i = 1; i <= n; ++i)
        cout << b[i] << ' ';
    cout << endl;
    
    return 0;
}
```

其中：

- 在计数排序的输入部分，我们用`cnt`数组统计了每种值出现的个数。
- 在维护最终有序序列的部分，我们按照值从小到大的顺序，放置相应`cnt`个元素到答案数组里。



## 代码实现 —— 计数排序2

### 找出原序列中的元素和答案数组中的对应

这里，我们给出另外一种计数排序的实现方法。其中

- 在输入部分，我们统计每一种值出现的次数
- 在求原序列和答案序列的位置对应关系的部分，我们对`cnt`数组求前缀和，并存储在`sum`中。回忆上一节提到，对于一个值`x`，`sum[x]`的含义是“小于等于`x`的数字个数”，同时，也可以看作指向答案序列中最后一个`x`出现的位置的指针。
- 然后，我们**从后向前**枚举原序列的每个元素`x`，将`sum[x]`指向的位置分配给它，存在`idx`数组中，然后将`sum[x]`前移。这里“从后向前”是因为考虑到对于同一个值，分配位置的顺序是从后向前。所以，我们从后向前枚举原序列，可以保证在**值相同的情况下**，**在原序列中出现在后面的元素会被分配到更大的位置**，也就保证列排序的**稳定性**。
- 因为原序列中`i`位置的数字，在答案序列中出现在`idx[i]`处。所以我们据此生成答案序列。

```cpp
#include <bits/stdc++.h>
#define N 1000005
#define K 1000001    // 假设非负整数最大元素范围为1000000
using namespace std;
int a[N], n, b[N];
int cnt[K], sum[K];
int idx[N];    // 用来记录原序列中每个元素在新序列中的位置
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        ++cnt[a[i]];    // 这里通过计数数组cnt来维护每一种值出现的次数
    }
    
    // 求原序列和答案序列中的位置对应
    sum[0] = cnt[0];               // 假设最小值为0
    for (int i = 1; i < K; ++i)    // 求cnt的前缀和
        sum[i] = sum[i - 1] + cnt[i];
    for (int i = n; i; --i)        // 给每个元素分配位置
        idx[i] = sum[a[i]]--;      // 之所以倒循环，是因为对于相等的元素我们是从后向前分配位置
                                   // 这样我们可以保证排序的稳定性
    
    // 根据求出的位置将每个元素放进答案序列中
    for (int i = 1; i <= n; ++i)
        b[idx[i]] = a[i];
	
    // 输出
    for (int i = 0; i <= n; ++i)
        cout << b[i] << ' ';
    cout << endl;
    
    return 0;
}
```



## 复杂度分析

### 计数排序代码简单实现

这里我们分析第一种计数排序实现方法。

```C++
#include <bits/stdc++.h>
#define N 1000005
#define K 1000001	// 假设非负整数最大元素范围为1000000
using namespace std;
int a[N], n, b[N];
int cnt[K];
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        ++cnt[a[i]];	// 这里通过计数数组cnt来维护每一种值出现的次数
    }
    
    // 维护最终有序序列
    for (int i = 0, j = 0; i < K; ++i)      // 枚举每一种值i，指针j用来枚举填充答案数组中的位置
        for (int k = 1; k <= cnt[i]; ++k)   // 根据该值出现的次数
            b[++j] = i;                     // 添加对应个数的i到答案序列
	
    // 输出
    for (int i = 1; i <= n; ++i)
        cout << b[i] << ' ';
    cout << endl;
    
    return 0;
}
```

其中

- 在计数排序的输入部分，我们用`cnt`数组统计了每种值出现的个数。
- 在维护最终有序序列的部分，我们按照值从小到大的顺序，放置相应`cnt`个元素到答案数组里。

### 找出原序列中的元素和答案数组中的对应

**空间复杂度**

因为在上面的代码中一共开了3个数组，长度分别为O(N)（对于`a`和`b`）和O(K)（对于`cnt`）。整个空间复杂度为`O(N + K)`。

**时间复杂度**

容易发现，算法的输入输出部分所占时间复杂度为O(n)。

在“维护有序序列”的部分，我们首先考虑最外层循环，因为它遍历了所有`[0..K]`的数字，所以它的复杂度是O(K)。

其次，我们考虑内层循环的循环次数，其在外层循环为`i`时为`cnt[i]`。因为对于不同的输入，以及外层循环枚举到的不同的`i`，`cnt[i]`差别很大。但如果我们把所有`i`对应的内层循环次数相加，即可得到：
$$
\text{内层循环总次数} = \sum_{i = 1}^{K} cnt[i] = n
$$
所以，整个算法的复杂度为$O(n + K)$。

我们提到过，有一条结论

> 所有基于比较的排序算法的时间复杂度都为$\Omega(n\log n)$。（$\Omega$和$O$记号类似，但O表示的是“不会超过”，而$\Omega$表示的是“不会少于”）。

我们看到当$K = O(n)$时，整个算法的时间复杂度为$O(n)$。之所以计数排序可以达到比$O(n\log n)$更好的时间复杂度，就是因为**它并不是基于比较的排序**。

对于基于原序列和答案序列位置对应设计的计数排序，经过分析可以发现其复杂度和第一种一样。大家可以自己尝试分析一下。



## 总结

- **计数排序**的**基本思想**是通过统计序列中不同的值出现的次数来排序。因为要用数组统计个数，所以要求在计数排序之前，整个序列中的元素需转换成**在很小范围`[0..K]`的非负整数**。
- **计数排序**的**算法描述**：

> 1. 统计原序列中每个值的出现次数，记为`cnt`数组。
> 2. 从小到大枚举值的范围，对`cnt`数组求前缀和，记为`sum`数组。
> 3. 从后往前枚举每个元素`a[i]`，分配其在答案中的位置`idx[i]`为当前的`sum[a[i]]`，也就是将其放在所有值等于`a[i]`中的最后一个。并且将`sum[a[i]]`减少`1`，保证下次再遍历到同样的值时，它分配的位置正好在`idx[i]`前面一个。

- **计数排序**的**代码实现1**：

```c++
#include <bits/stdc++.h>
#define N 1000005
#define K 1000001    // 假设非负整数最大元素范围为1000000
using namespace std;
int a[N], n, b[N];
int cnt[K];
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        ++cnt[a[i]];    // 这里通过计数数组cnt来维护每一种值出现的次数
    }
    
    // 维护最终有序序列
    for (int i = 0, j = 0; i < K; ++i)      // 枚举每一种值i，指针j用来枚举填充答案数组中的位置
        for (int k = 1; k <= cnt[i]; ++k)   // 根据该值出现的次数
            b[++j] = i;                     // 添加对应个数的i到答案序列
	
    // 输出
    for (int i = 1; i <= n; ++i)
        cout << b[i] << ' ';
    cout << endl;
    
    return 0;
}
```

> 其中：
>
> - 在计数排序的输入部分，我们用`cnt`数组统计了每种值出现的个数。
> - 在维护最终有序序列的部分，我们按照值从小到大的顺序，放置相应`cnt`个元素到答案数组里。

- **上述计数排序实现方法的时间和空间复杂度都是$O(n+K)$**。正因为它不是基于比较的排序，所以才能达到比$O(n\log n)$更好的时间复杂度。
- **计数排序**的基本思想还可以拓展成[**桶排序**](https://www.runoob.com/w3cnote/bucket-sort.html)和[**基数排序**](https://www.runoob.com/w3cnote/radix-sort.html)。使用桶排序和基数排序的，可以对更大范围内的，甚至不是整数的序列进行排序。



## 练习

### 统计数字_排序

某次科研调查时得到了n个自然数，每个数均不超过1500000000（1.5*10^9）。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。

**注：请选择合适排序方法完成本题。**

输入描述：

每组输入数据包含n+1行；

第一行是整数n，表示自然数的个数；

第2~n+1行，每行一个自然数。



数据规模：

40%的数据满足：1<=n<=1000；

80%的数据满足：1<=n<=50000；

100%的数据满足：1<=n<=200000，每个数均不超过1500000000（1.5*109）。



输出描述：

每组输出包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。



示例 1：

输入：

```
8
2
4
2
4
5
100
2
100
```

输出：

```
2 3
4 2
5 1
100 2
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[300000];  

int main(){

    int n, s = 1;
    cin >> n;
    for(int i = 1;i <= n;i++){
        cin >> a[i];
    }
    sort(a + 1,a + n + 1);        // 使用快速排序

    for(int i = 1; i <= n; i++){
        if(a[i] == a[i+1]){
            s++;                  // 计数
        }
        else{
            cout << a[i] << " " << s << endl;
            s = 1;
        }
    }
    return 0;
}

```





### 明明的随机数_排序

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

**注：请选择合适排序方法完成本题。**

输入描述：

每组输入有2行，第1行为1个正整数，表示所生成的随机数的个数N，第2行有N个用空格隔开的正整数，为所产生的随机数。



输出描述：

每组输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。


示例 1：

输入：

```
10
20 40 32 67 40 20 89 300 400 15
```

输出：

```
8
15 20 32 40 67 89 300 400
```



实现

```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 110
int a[N], n, cnt;

int main(){

    scanf("%d", &n);
    for (int i = 0; i < n; ++i) scanf("%d", &a[i]);

    for (int i = 1; i < n; ++i) 
        for (int j = 0; j < n - i; ++j)
            if (a[j] > a[j + 1]) swap(a[j], a[j + 1]);

    cnt = 0;
    for (int i = 0; i < n; ++i) 
        if (i == 0 || a[i] != a[i - 1]) 
            a[cnt++] = a[i];

    printf("%d\n", cnt);
    for (int i = 0; i < cnt; ++i) printf("%d ", a[i]); 
  
    return 0;
}

```

