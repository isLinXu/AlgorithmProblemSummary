# 归并排序

---

## 基本思想

回顾**快速排序**的基本思想：找出一个分界线，并以该分界线为界将数组分为两部分，在对这两部分以同样的方式分别排序。

但是！**快速排序**作为一种高效率的算法，它的**缺点**在于算法的复杂度很依赖**分界线的选取**。因为这决定了左右两边划分的元素个数**是否平衡**。

那么，我们能不能变通一下，规避这种情况带来的效率损失呢？

回忆**快速排序**中，正是因为分界线的存在，使得划分到两边的数字排好序后，通过分界线的连接，能够天然形成原序列的排序。但如果我们不设置分界线，而是直接把序列从中间分成相等的两份，然后两边分别排序，我们仍然可以**很快地**将两个有序序列合并成原序列的有序序列吗？

考虑右侧上下两个序列：

![img](https://staticcdn.boyuai.com/user-assets/5085/C5fRdBjdgKirqpCSZ8BHsp/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.jpg!jpg)

假如我们想找出这个两个序列中的最小值，它有可能出现在哪些位置呢？

因为上面的序列中，第一个元素最小，而下面的序列中，也是第一个元素最小。所以最小值只可能出现在**最左边两个元素中的一个**！

![img](https://staticcdn.boyuai.com/user-assets/5085/cg9o6j9oCqSQrtai1QUwEU/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.jpg!jpg)

所以通过比较最左边元素的大小，我们很容易就知道答案序列中第一个元素是`1`。

![img](https://staticcdn.boyuai.com/user-assets/5085/Bw1gTzURz3k27xVGv5FpSv/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F3.jpg!jpg)

同样的，剩下元素的最小值也必然出现在剩下两个序列的最左边，所以通过比较`2`和`3`的大小，我们能很容易确定答案序列中排第二的数字是`2`。

![img](https://staticcdn.boyuai.com/user-assets/5085/EHzYxs6SDQ9SczyzBP9uwn/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F4.jpg!jpg)

通过不断重复这个过程，最终我们将两个有序序列合并成了一个有序序列。

![img](https://staticcdn.boyuai.com/user-assets/5085/Pq2M2ePvpjkyfGfqJEAd4r/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F5.png!png)

所以，我们可以用和**快速排序**一样的框架，即**分治法**，来设计一个不依赖于分界线选择的排序算法。

回顾分治法的内容：

> **分治思想**是一种“分而治之”的思想，反应在解决问题当中，**就是将一个复杂问题不断分解为规模更小、更容易解决的问题**，从而提升解决问题的效率。而**分治法**就是基于分治思想得到的解决问题的方法，它分为下面三个步骤：
>
> 1. **问题的拆分**。例如在快速排序中，我们以某个元素为分界线，将待排序的数字分为两部分。
> 2. **解决子问题**。例如在快速排序中，如果子问题的规模为1，我们就直接解决它，否则，我们就使用和划分主问题同样的办法继续划分子问题直到子问题规模达到很容易直接解决为止。
> 3. **合并子问题的解**。例如在快速排序中，我们将左边右边分别排序后，将前后排好序的部分与中间的分界线连接，形成主问题的解。
>
> 分治思想在算法领域有非常广泛的应用，在很多**分解和合并都非常容易**的问题上，分治法都能够提升其算法效率。

**分治法**和**快速排序**的区别在于，划分的时候不需要设置分界线，而是直接将序列分成大小相等的左右两份。但合并时，因为没有分界线的存在，我们需要上面介绍的合并操作来将两个有序序列**互相穿插**，从而合并成一个有序序列。

在这里，我们将上面的合并操作称为“**归并操作**”。而基于**分治法**和**归并操作**形成的排序算法，我们将其称为**归并排序**。



## 详细算法描述

基于分治法的排序算法基本流程如下：

![img](https://staticcdn.boyuai.com/user-assets/5085/YQfQpkUVFdnaeHAgQY9q4Q/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F6.jpg!jpg)

可以看到，在算法的前半部分，整个算法在不断将序列分解，而在后半部分，整个算法在不断把子段合并。所以，我们分别来解释这两部分是怎样运行的。

### 分解阶段

在分解阶段，我们一步一步将其分解到长度为1的子段。注意在这个阶段，我们仅仅是划分，**并不改变元素在数组中的位置**。

![img](https://staticcdn.boyuai.com/user-assets/5085/XkV9NUaErNHPoZxmMB6WWN/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F7.jpg!jpg)

### 合并阶段

我们按照和刚才相反的顺序，自底向上合并。

首先在最底层，**子段长度为1**，每个字段已经是有序序列（因为长度为1的序列本身就是有序序列）。

![img](https://staticcdn.boyuai.com/user-assets/5085/7aYSEbkHZ6EGW5NuUHEzro/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F8.jpg!jpg)

回到上一阶段，**子段长度为2**。为了让每个子段中的序列都有序，我们需要将序列两两合并。

![img](https://staticcdn.boyuai.com/user-assets/5085/GeLM6kboBDDtaFj8w3huZn/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F9.jpg!jpg)

再回到上一层，**子段长度为4**。我们需要用同样的办法把相邻两个长度为2的有序子段合并。

![img](https://staticcdn.boyuai.com/user-assets/5085/cNmSpk8i7HNnEt6A9bQZoo/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F10.jpg!jpg)

最后，我们将两个长度为4的子段合并，就能得到完整的排好序的序列。

![img](https://staticcdn.boyuai.com/user-assets/5085/oncNuNiRkHiz36FxyaZ43c/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F11.jpg!jpg)

### 归并排序算法过程

所以，我们总结一下**归并排序的算法过程**：

- 假设我们要对数组`a[1..n]`排序。初始化左端点`l=1`，右端点`r=n`。
- 下面假设我们对`l`到`r`子段内的数字进行划分。取`l`和`r`的中点`mid`，将`l`到`mid`的元素看成第一个子段的部分，将`mid+1`到`r`的部分看成第二个子段的部分。两边分别进入下一层，重复调用上面的过程。直到子段长度为1，返回上一层。
- 当算法阶段返回到当前层时，使用归并操作合并下一层的左右两个有序序列，形成本层的有序序列，继续返回上一层。
- 当整个过程结束以后，整个序列排序完毕。



## 归并排序整体框架

首先，我们再来看一下**归并排序**的算法过程：

- 假设我们要对数组`a[1..n]`排序。初始化左端点`l=1`，右端点`r=n`。
- 下面假设我们对`l`到`r`子段内的数字进行划分。取`l`和`r`的中点`mid`，将`l`到`mid`的元素看成第一个子段的部分，将`mid+1`到`r`的部分看成第二个子段的部分。两边分别进入下一层，重复调用上面的过程。直到子段长度为1，返回上一层。
- 当算法阶段返回到当前层时，使用归并操作合并下一层的左右两个有序序列，形成本层的有序序列，继续返回上一层。
- 当整个过程结束以后，整个序列排序完毕。

和快速排序一样，在实现**归并排序**时我们仍然使用**递归函数的方式**。具体框架如下：

```c++
#include <bits/stdc++.h>
#define N 100010
using namespace std;
int n;
int a[N];

void merge_sort(int l, int r) { // l和r分别代表当前排序子段在原序列中左右端点的位置
    if (l >= r) return;         // 当子段为空或者长度为1，说明它已经有序，所以退出该函数
    int mid = l + r >> 1;       // 取序列的中间位置，并将序列分成两部分（左右长度相差最多为1）
                                // l + r 的值右移1位，相当 l + r 的值除以2取整。
    merge_sort(l, mid);         // 对``l``到``mid``第一个子段进行归并操作
    merge_sort(mid + 1, r);     // 对``mid+1``到``r``第二个子段子段进行归并操作
	
    /* 这里省略将数组a[l..mid]和数组a[(mid+1)..r]合并的过程。 */
}

int main() {
    // 输入
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	
    // 归并排序
    merge_sort(1, n);
	
    // 输出
    for (int i = 1; i <= n; ++i) printf("%d ", a[i]); 
    return 0;
}
```



实现

```cpp
#include <bits/stdc++.h>
#define N 100010 
using namespace std; 
int n = 5;
int a[6] = {0, 2, 4, 1, 6, 3}; 
int b[6] = {0, 0, 0, 0, 0, 0};

// 合并操作
void merge(int l, int r) {
    for (int i = l; i <= r; ++i) b[i] = a[i]; // 将a数组对应位置复制进辅助数组
    
    int mid = l + r >> 1;          // 计算两个子段的分界线
                                   // l + r 的值右移1位，相当 l + r 的值除以2取整。
    int i = l, j = mid + 1;        // 初始化i和j两个指针分别指向两个子段的首位
    for (int k = l; k <= r; ++k) { // 枚举原数组的对应位置
        // 如果：
        // 1. ``j``已经移出子段的末尾；
        // 2. 或者``i``和``j``都仍然指向子段中的元素，但``i``指向的元素比``j``指向的元素小；
        if (j > r || i <= mid && b[i] < b[j]) a[k] = b[i++]; 
        else a[k] = b[j++];
    }
}
```





代码实现 —— 归并操作

在归并操作的时候，我们使用一个辅助数组`b`，先把待合并的部分整个复制到`b`数组里，如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/2n2dQHCa4aWyqtr1a2Cs2C/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F12.jpg!jpg)

然后，我们用`k`枚举原序列中`l`到`r`的位置，依次从`b`数组中挑选元素填入当前位置`k`中。我们维护两个指针`i`，`j`，分别指向**两个子段的最小元素**。如果：

1. `j`已经移出子段的末尾；
2. 或者`i`和`j`都仍然指向子段中的元素，但`i`指向的元素比`j`指向的元素小；

那么我们将`i`指向的元素填到`k`的位置，并且将`i`后移。否则，就将`j`指向的元素填写到`k`的位置。详细代码如下：

```c++
int b[N]; // 辅助数组

void merge(int l, int r) {
    for (int i = l; i <= r; ++i) b[i] = a[i];	// 将a数组对应位置复制进辅助数组
    
    int mid = l + r >> 1;			// 计算两个子段的分界线
    int i = l, j = mid + 1;			// 初始化i和j两个指针分别指向两个子段的首位
    for (int k = l; k <= r; ++k) {	// 枚举原数组的对应位置
        if (j > r || i <= mid && b[i] < b[j]) a[k] = b[i++]; // 上文中列举的条件
        else a[k] = b[j++];
    }
}
```

右侧代码部分语句被挖空了，请在右侧代码中补全。运行验证正确后提交才可以解锁下一步哦～



实现

```cpp
#include <bits/stdc++.h>
#define N 100010 
using namespace std; 
int n = 5;
int a[6] = {0, 2, 4, 1, 6, 3}; 
int b[6] = {0, 0, 0, 0, 0, 0};
// 合并操作

void merge(int l, int r) {
    
    // TODO 请补全下述代码，完成归并操作
    for (int i = l; i <= r; ++i) b[i] = a[i]; // 将a数组对应位置复制进辅助数组
    
    int mid = l + r >> 1;          // 计算两个子段的分界线
    int i = l, j = mid + 1;        // 初始化i和j两个指针分别指向两个子段的首位
    for (int k = l; k <= r; ++k) { // 枚举原数组的对应位置
        // 如果：
        // 1. ``j``已经移出子段的末尾；
        // 2. 或者``i``和``j``都仍然指向子段中的元素，但``i``指向的元素比``j``指向的元素小；
        if (j > r || i <= mid && b[i] < b[j]) a[k] = b[i++];
        else a[k] = b[j++];
    }
}

void merge_sort(int l, int r) { // l和r分别代表当前排序子段在原序列中左右端点的位置
    if (l >= r) return;         // 当子段为空或者长度为1，说明它已经有序，所以退出该函数
    int mid = l + r >> 1;       // 取序列的中间位置，并将序列分成两部分（左右长度相差最多为1）
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    merge(l, r);                // 将l..mid和mid+1..r两个子段合并成完整的l..r的有序序列
}

int main() {

    // 归并排序 
    merge_sort(1, n);
	
    // 输出
    for (int i = 1; i <= n; ++i) printf("%d ", a[i]); 
    return 0;
}
```




## stable_sort函数使用

同样，归并排序实现起来也并不容易，所以STL中也有对归并排序的优化实现，函数名为`stable_sort`。使用方法与`sort`一样，见下例：

```c++
#include <bits/stdc++.h>
using namespace std;
int a[10] = {0, 2, 3, 1, 5, 4}; // 1-base，0号元素无意义
int n = 5;
bool cmp(int x, int y) {        // 比较函数，函数的参数是当前比较的两个数组中的元素
    return x > y;               // x和y分别为排序数组中的两个元素。
}                               // 当函数返回值为true时，x应该排在y的前面。
int main() {
    stable_sort(a + 1, a + n + 1, cmp);    // 比较函数作为第三个参数传入sort函数
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
}
```

之所以该函数叫做`stable_sort`，是因为归并排序是**稳定排序**，而快速排序不是**稳定排序**（这是因为选择作为分界线的点在不同实现中位置可能不一样。对于有些实现，当`i`被选为分界点，且该位置的值是`a[i]`时，它右边和`a[i]`相等的元素很有可能被换到`i`的左边，这时就破坏了稳定性）。回忆稳定排序的概念：

> **稳定性**描述的是对于有重复元素的序列，如果排序前后，**重复的元素相对位置不变**。这种叫做**稳定算法**，否则就是不稳定。参考下面的示意图：

![img](https://staticcdn.boyuai.com/user-assets/5085/gw3dddj3g9pBRVg92UjJDy/%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F.png!png)

右侧代码部分语句被挖空了，请在右侧代码中补全。运行验证正确后提交才可以解锁下一步哦～



## 总结

- 和快速排序一样，**归并排序**也是**基于分治法**的排序算法。其基本思想在于将待排序序列分成长度相差不超过1的两份，分别对左右子段进行同样的划分和排序过程，最后将两个已经排好序的子段合并成整个完整的有序序列。

- **归并排序**的**时间复杂度**是$O(n\log n)$，在实现时，需要**辅助数组**帮助合并子段，所以是一种**非原地排序算法**。

- 和快速排序不同的是，**归并排序是一种稳定排序**，即相同元素在排序前后的数组中相对位置不变。

- `stable_sort`函数是C++标准模板库（STL）中一种对归并排序的优化实现，可以通过传入头指针、尾指针和比较函数来对数组中的对象进行排序。

- 归并排序示例：

  将数组{2, 3, 1, 5, 4}从小到大排列。

- 不使用`stable_sort`函数

  将「整体框架」和「归并操作」进行合并，我们得到快速排序完整代码：

```c++
#include <bits/stdc++.h>
#define N 100010
using namespace std;
int n;
int a[N], b[N];

// 合并操作
void merge(int l, int r) {
    for (int i = l; i <= r; ++i) b[i] = a[i]; // 将a数组对应位置复制进辅助数组
    
    int mid = l + r >> 1;           // 计算两个子段的分界线
    int i = l, j = mid + 1;         // 初始化i和j两个指针分别指向两个子段的首位
    for (int k = l; k <= r; ++k) {  // 枚举原数组的对应位置
        if (j > r || i <= mid && b[i] < b[j]) a[k] = b[i++]; // 上文中列举的条件
        else a[k] = b[j++];
    }
}

void merge_sort(int l, int r) { // l和r分别代表当前排序子段在原序列中左右端点的位置
    if (l >= r) return;         // 当子段为空或者长度为1，说明它已经有序，所以退出该函数
    int mid = l + r >> 1;       // 取序列的中间位置，并将序列分成两部分（左右长度相差最多为1）
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    merge(l, r);                // 将l..mid和mid+1..r两个子段合并成完整的l..r的有序序列
}

int main() {
    // 输入
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	
    // 归并排序 
    merge_sort(1, n);
	
    // 输出
    for (int i = 1; i <= n; ++i) printf("%d ", a[i]); 
    return 0;
}
```

- 使用`stable_sort`函数

```c++
#include <bits/stdc++.h>
using namespace std;
int a[10] = {0, 2, 3, 1, 5, 4}; // 1-base，0号元素无意义
int n = 5;
bool cmp(int x, int y) {        // 比较函数，函数的参数是当前比较的两个数组中的元素
    return x > y;               // x和y分别为排序数组中的两个元素。
}                               // 当函数返回值为true时，x应该排在y的前面。
int main() {
    stable_sort(a + 1, a + n + 1, cmp);    // 比较函数作为第三个参数传入sort函数
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
}
```





## 练习

### 统计数字_归并排序

某次科研调查时得到了n个自然数，每个数均不超过1500000000（$1.5*10^9$）。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。

输入描述：

每组输入数据包含n+1行；

第一行是整数n，表示自然数的个数；

第2~n+1行，每行一个自然数。

数据规模：

40%的数据满足：1<=n<=1000；

80%的数据满足：1<=n<=50000；

100%的数据满足：1<=n<=200000，每个数均不超过1500000000（$1.5*10^9$）。

输出描述：

每组输出包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。

示例 1：

输入：

```
8
2
4
2
4
5
100
2
100
```

输出：

```
2 3
4 2
5 1
100 2
```



实现

```cpp
#include <bits/stdc++.h>
using namespace std;

// TODO 请补全下述`cmp`函数代码
bool cmp(int x, int y) {  // 比较函数，函数的参数是当前比较的两个数组中的元素
    return x < y;         // x和y分别为排序数组中的两个元素。
                 // 当函数返回值为true时，x应该排在y的前面。
  }                         

int a[300000];                    // 防止越界
int main(){
    int n, s = 1;
    cin >> n;
    for(int i = 1;i <= n;i++){
        cin >> a[i];
    }
    // TODO 请补全下述归并排序代码
    stable_sort(a + 1, a + n + 1,cmp) ; // 使用`stable_sort`函数进行快速排序
    
    for(int i = 1; i <= n; i++){
       if(a[i] == a[i+1]){
           s++;                  // 计数
       }
       else{
           cout << a[i] << " " << s << endl;
           s = 1;
        }
    }
    return 0;
}

```



### 数列排序_归并排序

给定一个长度为`n (1 <= n <= 100000)`的序列，请你将他们从小到大排序后再输出。

输入描述：

第一行一个整数`n`，表示序列长度。

第二行`n`个整数。

输出描述：

一行，`n`个整数，排序后的数列。

示例 1：

输入：

```
5
3 5 2 1 4
```

输出：

```
1 2 3 4 5
```


实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100010];

int main(){
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    stable_sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
  
    return 0;
}
```



