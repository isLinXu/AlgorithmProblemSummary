# 插入排序

---

## 基本思想

假设有一天你要赶火车，但是到火车站的时候时间已经不多了，而且火车站门口已经排起长长的队伍。通常情况下，你肯定希望队伍中的人通融一下，希望可以插个队。那么具体操作是怎样的呢？

你肯定会从队列最后面，一边向前走，一边说：“抱歉抱歉，我是一点半的火车，来不及了，希望借过一下”。那么，听到这句话的人如果火车时间比较充裕，并且也很通情达理的话，一般会让你排到他前面去。

可如果当你说完这句话的时候，你站的位置前面的人说：“别挤了，我是一点二十的火车，比你更急”。那么你就只能排在他后面了。

如果，我们把上面的故事抽象出来，并且严谨描述一下，它就变成了：

> 已知一个有序序列，向其中新加入一个元素，使得该序列变成长度加1的有序序列，其方法是令该元素从最后一个元素开始与序列中的元素依次比较，直到遇到一个元素小于它，就将新元素插入到这个元素的后面一位。这样就维护了一个长度+1的有序序列。

那么，回到排序的场景来，如果我们按照上述方式一个元素一个元素插入到当前已排序的序列中，最终就可以将全部元素排序。这种算法叫做**插入排序**。



## 详细算法描述

- 整理插入排序算法描述如下：

1. 枚举序列中第`2~n`个元素。
2. 当枚举元素`i`时，前`i-1`个元素已经有序。将第`i`个元素插入到前`i-1`个元素的有序序列中，形成长度为`i`的有序序列。
3. 枚举过程结束后，整个序列有序。

在上述算法描述中，我们有个关键的步骤——**插入操作**：

> 将第`i`个元素插入到前`i-1`个元素的有序序列中，形成长度为`i`的有序序列。

怎样实现这个过程呢？

一种实现思路和前面介绍的“火车站插队”过程十分类似。比如对于如下序列：

![img](https://staticcdn.boyuai.com/user-assets/5085/rDLQLETRF28H2Vn45ZETaj/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F1.jpg!jpg)

这个序列的前4个元素已经有序，现在我们要把`2`插入到前4个元素中去。

1. 首先让`2`出队。

![img](https://staticcdn.boyuai.com/user-assets/5085/fGiLLkVK2zoXPbrT9CgWz3/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F2.jpg!jpg)

1. 然后将其与`6`比较，发现`2<6`，说明`2`应该在`6`前面。所以我们将`6`向后移动。
2. 再将其与`5`比较，发现`2<5`，说明`2`应该排在`5`前面。所以我们将`5`向后移动。

![img](https://staticcdn.boyuai.com/user-assets/5085/ZRbwjJh5BN6Z7c9oiUxJTh/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F6.jpg!jpg)

![img](https://staticcdn.boyuai.com/user-assets/5085/DYVJm8rtTXGa3pBzNPRMYL/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F3.jpg!jpg)

1. 经过同样的分析，`4`也应该向后移。

![img](https://staticcdn.boyuai.com/user-assets/5085/y93H11upq3KpeyUryufUNc/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F4.jpg!jpg)

1. 最后我们将`2`与`1`比较，发现`1<2`，说明`2`应该放在`1`的后面。正好经过前面的移动，`1`后面有一个空位，所以我们把`2`插入在这个空位中。

![img](https://staticcdn.boyuai.com/user-assets/5085/LhRAgFUxNMmAQJPXhry6eU/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F5.jpg!jpg)

以上就是我们将一个新的元素`2`插入前面有序序列`a`的过程。

> 因为前面的序列有序，所以在整个序列中一定有一条分界线`j`，使得分界线前面的元素（`i<j`），都满足`a[i]<=2`;
>
> 对于分界线及分界线以后的元素（`i>=j`），都满足`a[i]>2`;
>
> 所以，上面的移动一定可以将分界线及以后的元素向后移动一位，空出分界线的位置`j`，然后将`2`插入到`j`号元素中。

所以，我们总结一下插入操作的算法描述：

1. 假设序列`1~(i-1)`已经有序, 从`i`到`1`枚举分界线的下标`j`;
2. 如果分界线前面的元素`a[j-1]`大于`x`，说明`a[j-1]`应该在分界线后面。所以将`a[j-1]`移动到`a[j]`，分界线前移变成`j-1`。
3. 如果分界线前面没有元素（`j=1`），就将`x`放在数组第1位。否则如果碰到一个`j-1`号元素小于等于`x`，说明分界线位置正确，就将`x`插到`j`位。



## 插入排序代码框架

回顾上面插入排序的算法描述：

> 1. 枚举序列中第`2~n`个元素。
> 2. 当枚举元素`i`时，前`i-1`个元素已经有序。将第`i`个元素插入到前`i-1`个元素的有序序列中，形成长度为`i`的有序序列。
> 3. 枚举过程结束后，整个序列有序。

我们得出了插入排序的代码框架。

```c++

#include <bits/stdc++.h>
#define N 1550
using namespace std;
int a[N], n;

int main() {
    // 输入
    cin >> n; 
    for (int i = 1; i <= n; ++i) cin >> a[i];
	
    // 插入排序
    for (int i = 2; i <= n; ++i) {  // 按照第2个到第n个的顺序依次插入
        int j, x = a[i];            // 之所以要将a[i]赋给一个临时变量x，
                                    // 就是因为前面元素向后移动的过程中，
                                    // 可能会覆盖a[i]。
        
        /* 此处先省略过程寻找分界线j，并将分界线及以后的元素向后移动。在下一步骤中讲解*/
        
        a[j] = x;    // 当前待插入元素x，插入到分界线j的位置
    }
	
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```



知道了插入排序代码框架以后，我们开始介绍插入操作的代码。

回忆一下插入操作的算法过程：

> 1. 假设序列`1~(i-1)`已经有序, 从`i`到`1`枚举分界线的下标`j`;
> 2. 如果分界线前面的元素`a[j-1]`大于`x`，说明`a[j-1]`应该在分界线后面。所以将`a[j-1]`移动到`a[j]`，分界线前移变成`j-1`。
> 3. 如果分界线前面没有元素（`j=1`），就将`x`放在数组第1位。否则如果碰到一个`j-1`号元素小于等于`x`，说明分界线位置正确，就将`x`插到`j`位。

因为这基于一个“如果条件满足，就一直执行某过程”的逻辑，

所以我们应该用`while`循环或者借助`for`循环中的条件部分来实现。假设我们待插入元素在`i`号位：

```c++
int j, x = a[i];    // 先将i号元素用临时变量保存防止被修改。

// 插入过程，目的是空出分界线位置j，使得所有<j的部分<=x，所有>j的部分>x。
// 循环维持条件，j不是第一个，并且j前面的元素>x。
for (j = i; j > 1 && a[j - 1] > x; --j) {   
    // 满足循环条件，相当于分界线的位置还应向前移，
    // 分界线向前移，就等于将分界线前面>x的元素向后移
    a[j] = a[j - 1];                         
                                             
}
// 循环结束，分界线位置正确
a[j] = x;                                    
```





## 完整插入排序

将上述步骤（代码框架和插入操作）两步骤合并，就有了完整的插入排序代码：

```C++
#include <bits/stdc++.h>
#define N 1550
using namespace std;
int a[N], n;

int main() {
    // 输入
    cin >> n; 
    for (int i = 1; i <= n; ++i) cin >> a[i];
	
    // 插入排序
    for (int i = 2; i <= n; ++i) {    // 按照第2个到第n个的顺序依次插入
        int j, x = a[i];    // 先将i号元素用临时变量保存防止被修改。

        // 插入过程，目的是空出分界线位置j，使得所有<j的部分<=x，所有>j的部分>x。
        // 循环维持条件，j>1，并且j前面的元素>x。
        for (j = i; j > 1 && a[j - 1] > x; --j) {   
            // 满足循环条件，相当于分界线应向前移，
            // 分界线向前移，就等于将分界线前面>x的元素向后移
            a[j] = a[j - 1];              
                                                    
        }
        // 找到分界线位置，插入待插入元素x
        a[j] = x;                         
    }
	
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```



## 总结

- 插入排序的基本思想就是**不断扩展有序序列的长度**。

  > 具体方式是对于一个有序序列，如果想在其中新加入一个元素，就应通过**插入操作**找出正确的插入位置，并且将插入位置空出来，然后插入新元素。

- **插入操作**的基本思想就是从后向前**不断“试探”分界线的位置**。

  > 一个合法的分界线，分界线前的元素需满足小于等于新元素大小，分界线后元素需满足大于新元素大小。所以寻找分界线的过程，就是不断把当前在分界线前，但本应该在分界线后的元素向后移动。

- **插入操作**的算法描述：

  1. 假设序列`1~(i-1)`已经有序, 从`i`到`1`枚举分界线的下标`j`;
  2. 如果分界线前面的元素`a[j-1]`大于`x`，说明`a[j-1]`应该在分界线后面。所以将`a[j-1]`移动到`a[j]`，分界线前移变成`j-1`。
  3. 如果分界线前面没有元素（`j=1`），就将`x`放在数组第1位。否则如果碰到一个`j-1`号元素小于等于`x`，说明分界线位置正确，就将`x`插到`j`位。

  - 完整**插入排序**的代码实现：

  ```C++
  #include <bits/stdc++.h>
  #define N 1550
  using namespace std;
  int a[N], n;
  
  int main() {
      // 输入
      cin >> n; 
      for (int i = 1; i <= n; ++i) cin >> a[i];
  	
      // 插入排序
      for (int i = 2; i <= n; ++i) {    // 按照第2个到第n个的顺序依次插入
          int j, x = a[i];    // 先将i号元素用临时变量保存防止被修改。
  
          // 插入过程，目的是空出分界线位置j，使得所有<j的部分<=x，所有>j的部分>x。
          // 循环维持条件，j>1，并且j前面的元素>x。
          for (j = i; j > 1 && a[j - 1] > x; --j) {   
              // 满足循环条件，相当于分界线应向前移，
              // 分界线向前移，就等于将分界线前面>x的元素向后移
              a[j] = a[j - 1];              
                                                      
          }
          // 找到分界线位置，插入待插入元素x
          a[j] = x;                         
      }
  	
      // 输出
      for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
      cout << endl;
      return 0;
  }
  ```

  - 时间复杂度分析：

  **插入排序的总时间复杂度**是O(n^2)。



## 练习

### 明明的随机数_插入排序

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

输入描述：

每组输入有2行，第1行为1个正整数，表示所生成的随机数的个数N，第2行有N个用空格隔开的正整数，为所产生的随机数。

输出描述：

每组输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

示例 1：

输入：

```
10
20 40 32 67 40 20 89 300 400 15
```

输出：

```
8
15 20 32 40 67 89 300 400
```

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 110
using namespace std;
int a[N], n, cnt;

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) 
        scanf("%d", &a[i]);

    
    for (int i = 1; i < n; ++i) {   
        int j, x = a[i];	
        // TODO 请补全代码完成插入排序
        for (j = i;  j > 0 && a[j - 1] > x ; --j) {    
            a[j] = a[j - 1];                                                                              
        }
        // TODO 请补全代码完成插入排序
        a[j] = x  ;                                    
    }

    cnt = 0;
    for (int i = 0; i < n; ++i) 
        if (i == 0 || a[i] != a[i - 1]) 
            a[cnt++] = a[i];
            
    printf("%d\n", cnt);
    for (int i = 0; i < cnt; ++i) printf("%d ", a[i]); 
    return 0;
}

```



### 简单排序_插入排序

给定一个长度为`n (1 <= n <= 1000)`的序列，请你将他们从小到大排序后再输出。

输入描述：

第一行一个整数`n`，表示序列长度。

第二行`n`个整数。

输出描述：

一行，`n`个整数，排序后的数列。

示例 1：

输入：

```
5
3 5 2 1 4
```

输出：

```
1 2 3 4 5 
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[1010];

int main() {
    // 请补全代码，实现题目功能
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
    return 0;
}

```



