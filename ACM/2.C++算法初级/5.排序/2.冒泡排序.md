# 冒泡排序

---

## 基本思想

试想一下，如果在上体育课的时候，通常学生都会随意站成一列，但是体育老师会帮忙调整学生的站位使得最终顺序是按照身高排序的。那么，回忆一下体育老师是如何调整顺序的呢？

假设体育老师想将学生从左到右按照身高从矮到高排序。通常情况下，他会从左到右扫视学生的身高。如果左边有一个同学，个子比右边的同学高，他就要将其进行调整。具体调整方法是：

> - 如果一个同学比他右边的同学高，就让这两个同学交换位置。
> - 如果交换过后，这个同学仍然比新的右边的同学高，那么继续交换，直到他不在比右边的同学高。
> - 这样进行了若干次以后，队列就按照身高排好序了。

那么，如何严谨地表述“体育老师排序方法”，并对于任意给定的序列，都能将其从小到大排好序呢？

回忆在介绍选择排序的时候，我们的具体思路如下：

![img](https://staticcdn.boyuai.com/user-assets/5085/HU7mkuGBEuAR9BYJGa7R4i/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg!jpg)

我们发现，这里我们使用了**将原问题转换为规模更小的子问题**的思路。

所以在选择排序的过程，相当于每次将当前序列未排序部分的最小元素归位，将未排序的序列长度缩小一位。同样，如果我们能够通过某种方式，**把序列中的最大值移动到序列最后面**，也可以起到将未排序序列长度缩小一位的效果。

![img](https://staticcdn.boyuai.com/user-assets/5085/ErKjDg8hNUMV9w5fFtVSez/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.jpg!jpg)

所以，这节课我们设计的排序过程分为两步：

1. 通过“体育老师交换方法”，使得每次我们都能把最大值移动到序列的最后一位。
2. 利用上面的步骤进行问题转换，将未排序的序列长度缩减一个。

这就是**冒泡排序**的具体思路，而上面提到的“将最大值移动到最后一位”的操作，就叫做**冒泡操作**。



详细算法描述

### 冒泡排序的思路

- 总结冒泡排序的思路：

1. 冒泡排序分为`n-1`个阶段。
2. 在第`1`个阶段，通过“**冒泡**”，将前`n`个元素的最大值移动到序列的最后一位。此时只剩前`n-1`个元素未排序。
3. 在第`i`个阶段，此时序列前`n-i+1`个元素未排序。通过“**冒泡**”，我们将前`n-i+1`个元素中的最大值移动到最后一位。此时只剩前`n-i`个元素未排好序。
4. 最终到第`n-1`个阶段，前2个元素未排序。将其中的较大值移动到后一位，则整个序列排序完毕。

在上面的算法过程中，我们提到“冒泡”将序列中的最大值移动到最后一位。下面，我们介绍一下“冒泡”的过程：

### 冒泡过程

对于长度为`n`的序列，如何将其中的最大值移动到最后一位？

就像上面说的那样，如果相邻两个元素（如下图2和3），第一个大，第二个小，那么，将两个元素交换。

![img](https://staticcdn.boyuai.com/user-assets/5085/eEhYRkSZhAWdPq59LTAnw9/%E7%AB%99%E9%98%9F%E5%88%97-1.jpg!jpg)

如果我们对一段序列**从左到右连续**做如下**交换**操作：

```C++
if (a[i] > a[i + 1]) swap(a[i], a[i + 1])；
```

它的效果相当于将每一个”极大值“元素，移动到能到达的最远的位置。

![img](https://staticcdn.boyuai.com/user-assets/5085/6mhXTNqnkzx3du2Kf5ndhq/%E7%AB%99%E9%98%9F%E5%88%97-2.jpg!jpg)

自然，序列中的**最大值**，也是一个极大值，而它能被移动到的最远的位置，就是序列的最后一位。

所以，如果对于序列的`1~n`位，想将其中的最大元素”冒泡“到最后一位，那么就需要从第`1`位开始，一直到第`n-1`位，依次进行上面的交换过程。



### 代码实现1 —— 冒泡过程

我们分别给出单独的“冒泡过程”和完整的“冒泡排序”的代码。

冒泡过程就是一个从第`1`位到第`n`位进行的**连续交换**过程。其思路如下：

1. 冒泡排序分为`n-1`个阶段。

2. 在第`1`个阶段，**通过“冒泡”**，我们将前`n`个元素的最大值移动到序列的最后一位。此时只剩前`n-1`个元素未排序。

3. 在第`i`个阶段，此时序列前`n-i+1`个元素未排序。**通过“冒泡”**，我们将前`n-i+1`个元素中的最大值移动到最后一位。此时只剩前`n-i`个元素未排好序。

   对一段序列**从左到右连续**做**交换**操作的代码：

```C++
if (a[i] > a[i + 1]) swap(a[i], a[i + 1])；
```

1. 最终到第`n-1`个阶段，前2个元素未排序。我们将其中的较大值移动到后一位，则整个序列排序完毕。

代码如下：

```c++
#include <bits/stdc++.h>
#define N 1010
using namespace std;
int n, a[N];
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 冒泡阶段：连续交换过程
    for (int i = 1; i < n; ++i)    // 枚举两两交换的前一个元素序号
        if (a[i] > a[i + 1]) swap(a[i], a[i + 1]);    // 如果前一个元素大于后一个，就进行交换
    
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```

 冒泡阶段

**冒泡过程**就是一次从第`1`位到第`n`位进行的**连续交换**过程。：

总结**冒泡排序**的思路：

1. 冒泡排序分为`n-1`个阶段。

2. 在第`1`个阶段，**通过“冒泡”**，我们将前`n`个元素的最大值移动到序列的最后一位。此时只剩前`n-1`个元素未排序。

3. 在第`i`个阶段，此时序列前`n-i+1`个元素未排序。**通过“冒泡”**，我们将前`n-i+1`个元素中的最大值移动到最后一位。此时只剩前`n-i`个元素未排好序。

   对一段序列**从左到右连续**做**交换**操作的代码：

```C++
if (a[i] > a[i + 1]) swap(a[i], a[i + 1])；
```

1. 最终到第`n-1`个阶段，前2个元素未排序。我们将其中的较大值移动到后一位，则整个序列排序完毕。

请根据**冒泡排序**的思路补全右侧的代码。

右侧代码部分语句被挖空了，请在右侧代码中补全。运行验证正确后提交才可以解锁下一步哦～

```cpp
// 参考答案
int main() {    
    // 连续交换过程
    // TODO 请补全代码完成阶段的冒泡过程
    // 一共n-1个阶段，在第i个阶段，未排序序列长度从n-i+1到n-i。
    for (int i = 1; i < n; ++i) {  
        // 将序列从1到n-i+1的最大值，移到n-i+1的位置
        for (int j = 1; j <= n - i; ++j) 
            // 其中j枚举的是前后交换元素的前一个元素序号
            // TODO 请补全代码完成阶段的冒泡过程
            if (a[j] > a[j + 1]) 
                swap(a[j], a[j + 1]);
    }
    
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```





### 代码实现2 —— 完整冒泡排序

冒泡排序的过程，就是`n-1`个冒泡阶段。

这些冒泡阶段的作用就是按照最大值、第二大值、第三大值……的顺序，分别将其移动到序列的最后一位、倒数第二位、倒数第三位……。

```C++
    // 冒泡排序
    for (int i = 1; i < n; ++i) { 	// 一共n-1个阶段，在第i个阶段，未排序序列长度从n-i+1到n-i。
        for (int j = 1; j <= n - i; ++j)	// 将序列从1到n-i+1的最大值，移到n-i+1的位置
            if (a[j] > a[j + 1]) 			// 其中j枚举的是前后交换元素的前一个元素序号
                swap(a[j], a[j + 1]);
    }
```

完整的程序代码：

```C++
#include <bits/stdc++.h>
#define N 1010
using namespace std;
int n, a[N];
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 冒泡排序
    for (int i = 1; i < n; ++i) { 	// 一共n-1个阶段，在第i个阶段，未排序序列长度从n-i+1到n-i。
        for (int j = 1; j <= n - i; ++j)	// 将序列从1到n-i+1的最大值，移到n-i+1的位置
            if (a[j] > a[j + 1]) 			// 其中j枚举的是前后交换元素的前一个元素序号
                swap(a[j], a[j + 1]);
    }
    
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```



从代码中，我们可以看到冒泡排序的主干部分有两层循环，并且每一层的循环次数都在$O(n)$左右的数量级。

所以完整的冒泡排序时间复杂度是$O(n^2)$。

冒泡排序的过程，就是`n-1`个冒泡阶段。这些冒泡阶段的作用就是按照最大值、第二大值、第三大值……的顺序，分别将其移动到序列的最后一位、倒数第二位、倒数第三位……。

总结**冒泡排序**的思路：

1. 冒泡排序分为`n-1`个阶段。

2. 在第`1`个阶段，**通过“冒泡”**，我们将前`n`个元素的最大值移动到序列的最后一位。此时只剩前`n-1`个元素未排序。

3. 在第`i`个阶段，此时序列前`n-i+1`个元素未排序。**通过“冒泡”**，我们将前`n-i+1`个元素中的最大值移动到最后一位。此时只剩前`n-i`个元素未排好序。

   对一段序列**从左到右连续**做**交换**操作的代码：

```C++
if (a[i] > a[i + 1]) swap(a[i], a[i + 1])；
```

1. 最终到第`n-1`个阶段，前2个元素未排序。我们将其中的较大值移动到后一位，则整个序列排序完毕。



## 总结

- 冒泡排序和选择排序一样，都是将原问题转换为长度减一的子问题的过程。

- 冒泡排序分为`n-1`个阶段，每个阶段通过“冒泡”的过程，将未排序序列中的最大值移动到最后一位。

- 冒泡的过程，具体是通过一段连续交换过程使得最大元素被“传送”到最后一位。

- 冒泡排序的思路：

  1. 冒泡排序分为`n-1`个阶段。

  2. 在第`1`个阶段，**通过“冒泡”**，我们将前`n`个元素的最大值移动到序列的最后一位。此时只剩前`n-1`个元素未排序。

  3. 在第`i`个阶段，此时序列前`n-i+1`个元素未排序。**通过“冒泡”**，我们将前`n-i+1`个元素中的最大值移动到最后一位。此时只剩前`n-i`个元素未排好序。

     对一段序列**从左到右连续**做**交换**操作的代码：

  ```C++
  if (a[i] > a[i + 1]) swap(a[i], a[i + 1])；
  ```

  1. 最终到第`n-1`个阶段，前2个元素未排序。我们将其中的较大值移动到后一位，则整个序列排序完毕。

- 完整冒泡排序的代码实现：

```C++
#include <bits/stdc++.h>
#define N 1010
using namespace std;
int n, a[N];
int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 冒泡排序
    for (int i = 1; i < n; ++i) { 	// 一共n-1个阶段，在第i个阶段，未排序序列长度从n-i+1到n-i。
        for (int j = 1; j <= n - i; ++j)	// 将序列从1到n-i+1的最大值，移到n-i+1的位置
            if (a[j] > a[j + 1]) 			// 其中j枚举的是前后交换元素的前一个元素序号
                swap(a[j], a[j + 1]);
    }
    
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```

- 复杂度分析

从代码中，我们可以看到冒泡排序的主干部分有两层循环，并且每一层的循环次数都在$O(n)$左右的数量级。

所以完整的冒泡排序时间复杂度是$O(n^2)$。



## 练习

### 简单排序_冒泡排序

给定一个长度为`n (1 <= n <= 1000)`的序列，请你将他们从小到大排序后再输出。

输入描述：

第一行一个整数`n`，表示序列长度。

第二行`n`个整数。

输出描述：

一行，`n`个整数，排序后的数列。

示例 1：

输入：

```
5
3 5 2 1 4
```

输出：

```
1 2 3 4 5 
```

实现

```cpp
#include <bits/stdc++.h>
using namespace std; 
#define N 1010
int n, a[N];
int main() {
    // 请补全代码，实现题目功能
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 冒泡排序
    for (int i = 1; i < n; ++i) { 	// 一共n-1个阶段，在第i个阶段，未排序序列长度从n-i+1到n-i。
        for (int j = 1; j <= n - i; ++j)	// 将序列从1到n-i+1的最大值，移到n-i+1的位置
            if (a[j] > a[j + 1]) 			// 其中j枚举的是前后交换元素的前一个元素序号
                swap(a[j], a[j + 1]);
    }
    
    // 输出
    for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```









