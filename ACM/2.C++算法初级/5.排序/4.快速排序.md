# 快速排序

---

## 基本思想

我们知道，给一个长度为`n`的序列排序，有三种很简单的算法：**选择排序**、**冒泡排序**、**插入排序**。这三种算法的复杂度均为O(n^2)。

如果按照计算机1秒钟可以进行$10^8$次计算作为参照，那么它1秒之内可以排序的序列长度大概为$10^4$这个数量级。

然而，在实际生活中，$10^4$级别并不是一个很大的数字，比如说山东每年会有超过50万人参加高考。如果我们想将山东省内所有学生按照高考成绩排序的话，使用$O(n^2)$将会运行：
$$
\frac{(50 \times 10^4)^2}{10^8} = 2500秒 \approx 41分钟
$$
不得不说，这样的算法并不算高效。那么，我们能不能设计出更高效的算法呢？

- **一种优化方法**

假设现在，我们只想对`1~n`的数字排序。并且现在我们有个排序算法，运行复杂度刚好是n^2*n*2。

如果：

> 先把该序列**分成两部分**，一部分是`1~(n/2)`，另一部分是`(n/2+1)~n`；
>
> 然后对两个序列进行**分别排序** ；
>
> 最后再将两部分**贴在一起**，这个算法的复杂度是多少呢？

1.首先，**我们将序列分为长度相等的大小两部分**。

> 此时我们需要将所有`<=n/2`的数字调出来放到一边;
>
> 将所有`>n/2`的数字挑出来放到另一边;
>
> 这个步骤相当于将所有数字看一遍，所以复杂度是O(n)。

2.然后，**我们使用原来掌握的排序算法**，**分别给分好的两个序列排序**。

> 因为两个序列的长度都是`n/2`，所以两边排序的复杂度都是$(n/2)^2 = n^2/4$。两部分排序的总复杂度是$(n^2/4) * 2 = n^2$。

3.最后，**我们需要把两部分的排序结果贴在一起**。

> 这个操作几乎不费时间。

所以，我们最终复杂度将是$n^2/2 + n$。和原来直接运行排序算法得到复杂度为$n^2$相比，我们节省了**近一半的时间**！

由此，我们只需要将原序列划分一下，两边分别排序，最后将该序列合并，就能节省一半的时间（此时因为复杂度仍为平方级别，所以，我们只是在原算法的基础上**优化一个常数**）。

那么，我们能不能进一步优化该算法呢？



### 进一步优化

我们整理一下该算法的结构：

![img](https://staticcdn.boyuai.com/user-assets/5085/BLzYqSgtuGqkPXhEKtzkFy/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.jpg!jpg)

可以发现两个绿色部分的任务就是**原排序问题的一个子问题 — 给`n/2`个元素排序**！

所以，我们完全可以将绿色的任务进一步分解，如下图：

![img](https://staticcdn.boyuai.com/user-assets/5085/YKL6dMZL7xESYQduiFPhv5/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.jpg!jpg)

在这里，我们再尝试算一下整个算法的复杂度：

- 假如我们只看由**长度为`n/2`的序列排序**分解为两个**长度为`n/4`的序列排序**。那么，我们可以得到一个复杂度为
  $$
  (n/2)^2 / 2 + (n/2) = n^2 / 8 + (n/2)
  $$
  
- 然后，我们重新分析长度为`n`的序列分解为两个长度为`n/2`的序列。可以得到

  > 1. 首先，我们将序列分为长度相等的大小两部分。此时我们需要将所有`<=n/2`的数字调出来放到一边，将所有`>n/2`的数字挑出来放到另一边。这个步骤相当于将所有数字看一遍，所以复杂度是O(n)。
  > 2. 然后，我们使用原来掌握的排序算法，分别给分好的两个序列排序。因为两个序列的长度都是`n/2`，所以两边排序的复杂度都是$n^2/8 + n/2$。两部分排序的总复杂度是$n^2/4 + n$。
  > 3. 最后，**我们需要把两部分的排序结果贴在一起**。这个操作几乎不费时间。

  所以该算法的总复杂度变成了$n^2/4 + 2n$。可以发现，在该算法中，多分解了一层，而复杂度也进一步减少了。

  由此我们可以产生一个感觉，分解得越复杂度越小。所以，我们完全可以进一步分解，直到最后每个单位排序的长度为1。

![img](https://staticcdn.boyuai.com/user-assets/5085/xW6CHBftkSL3tWBLfstPNV/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F3.jpg!jpg)

这个就是**快速排序**的基本思想。



### 1~n 元素排序

我们先思考一下刚刚描述的**快速排序的基本思想**：

> 1. 当需要将`1`到`n`的`n`个数排序时，我们通过分解，将该问题分解为两个将`n/2`个数排序的子问题;
> 2. 在每个子问题中，我们继续分解，直到最后子问题长度为`1`;
> 3. 此时，整个序列就完成排序了。

下面，我们以将`1~8`的数字排序为例，详细介绍一下整个过程：

算法开始前，整个序列：

![img](https://staticcdn.boyuai.com/user-assets/5085/CduZwKuTLD3tiSsNnUumNx/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F4.jpg!jpg)

**第一层**（子段长度为`8`）

1. 首先，我们找到`4`的位置（因为`4`刚好是`8/2`），

![img](https://staticcdn.boyuai.com/user-assets/5085/4Hv5QhfnhvBFCCXB532jQA/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F5.jpg!jpg)

1. 然后把`<4`的数字移动到序列左边，`>4`的数字移动到序列右边。此时，`4`的位置已经固定了。

![img](https://staticcdn.boyuai.com/user-assets/5085/ZKBiuernnr9BWgxmtMGEPG/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F6.jpg!jpg)

**第二层**（子段长度为`<=4`）

1. 在这里，我们对4左边和右边的部分分别运行刚才的算法。

> 这是因为我们把`<4`和`>4`的部分移动到`4`的两边以后，这两个部分形成了两个**独立的子段**，
>
> 也就是说，在最终排好序的序列里，左边的元素不会移动到右边，右边的元素不会移动到左边。
>
> 所以，我们分别找出两边中点`2`和`6`的位置，

![img](https://staticcdn.boyuai.com/user-assets/5085/5rvPACrSzTj7bUjyziuMoU/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F7.jpg!jpg)

1. 然后把`<2 (or 6)`的和`>2 (or 6)`的部分分别移动到数字两边。

![img](https://staticcdn.boyuai.com/user-assets/5085/jXhLfEamQuupNQaPGKZuqB/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F8.jpg!jpg)

至此，`2`和`6`的位置也固定下来了。

**第三层**（子段长度`<=2`）

1. 最后，我们仍需对`2`边和`6`两边的子段重复刚才的算法。

> 然而，`2`两边，以及`6`左边的子段长度已经只有`1`了，这说明这些元素也已经放在正确的位置上了，
>
> 只有`6`右边的部分长度仍然`>1`。所以，我们只需对这部分重复刚才的操作，于是我们寻找出中点`7`的位置，

![img](https://staticcdn.boyuai.com/user-assets/5085/jsQmm2Gd7b2j42nSmbPvRk/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F9.jpg!jpg)

1. 最终，我们将`8`移动到`7`的右边，`7`的位置也放置正确了。

![img](https://staticcdn.boyuai.com/user-assets/5085/5qrumMMkTj1yaXjzqnuo6t/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F10.jpg!jpg)

**第四层**（子段长度`<=1`）

1. 因为`7`右边部分子段长度为`1`，所以直接说明该子段元素位置是正确的。所以，我们就完成了对整个序列的排序。



### 任意长度为n的序列排序

当然快速排序也可用来给任意`n`个数的序列排序。但是与和`1~n`排序不同的是，对于任意`n`个数的序列，我们在划分子段的时候**并不能很容易找到整个序列的“中位数”**。所以只能在序列中任意取一个数。比如

- 取整个序列中最左边的数。
- 取整个序列中最右边的数。
- 在整个序列中随机一个位置并取该位置上的数。

都是常见的取数策略。

但由于不能保证每次取的数字都刚好是中位数，**所以每次划分时也不能保证左边子段长度和右边子段长度非常平均**。如果“不幸”选到不合适的数（比如整个子段中最小的数或最大的数），整个算法的效率会降低很多。

在此，我们详细描述一下**给任意`n`个数排序的快速排序算法**：

1. 假设我们要对数组`a[1..n]`排序。初始化区间`[1..n]`。
2. 令`l`和`r`分别为当前区间的左右端点。下面假设我们对`l`到`r`子段内的数字进行划分。取`pivot = a[l]`为分界线，将`<pivot`的数字移到左边，`>pivot`的数字移到右边，然后将`pivot`放在中间。假设`pivot`的位置是`k`。
3. 如果左边区间`[l..k-1]`长度大于1，则对于新的区间`[l..k-1]`，重复调用上面的过程。
4. 如果右边区间`[k+1..r]`长度大于1，则设置新的区间`[k+1, r]`，重复调用上面的过程。
5. 当整个过程结束以后，整个序列排序完毕。



## 快速排序整体框架

回顾一下**给任意`n`个数排序的快速排序算法**：

1. 假设我们要对数组`a[1..n]`排序。初始化区间`[1..n]`。
2. 令`l`和`r`分别为当前区间的左右端点。下面假设我们对`l`到`r`子段内的数字进行划分。取`pivot = a[l]`为分界线，将`<pivot`的数字移到左边，`>pivot`的数字移到右边，然后将`pivot`放在中间。假设`pivot`的位置是`k`。
3. 如果左边区间`[l..k-1]`长度大于1，则对于新的区间`[l..k-1]`，重复调用上面的过程。
4. 如果右边区间`[k+1..r]`长度大于1，则设置新的区间`[k+1, r]`，重复调用上面的过程。
5. 当整个过程结束以后，整个序列排序完毕。

因为上面的算法描述中，出现了在步骤`2~4`里调用整个步骤的过程。如果我们用一个函数来表示整个步骤`2~4`，那么这个函数就出现了“调用自己”的情况。所以，我们用**递归函数**来实现这个过程。

```c++

// 该代码参考 https://www.geeksforgeeks.org/quick-sort/
#include <bits/stdc++.h>
#define N 100010 
using namespace std; 
int n; 
int a[N]; 
 
void quick_sort(int l, int r) { 	
    // l和r分别代表当前排序子段在原序列中左右端点的位置
    // 设置最右边的数为分界线
    int pivot = a[r];
    int k;
    
    /* 此处省略了元素移动和确定分界线新位置k的过程 */
    
    if (l < k - 1) quick_sort(l, k - 1); // 如果序列的分界线左边的子段长度>1，排序
    if (k + 1 < r) quick_sort(k + 1, r); // 如果序列的分界线右边的子段长度>1，排序
    // 上面的过程结束后，到这里左子段和右子段已经分别排好序。又因为确定分界线以后的移动操作
    // 保证了左子段中的元素都小于等于分界线，左子段中的元素都大于分界线。所以整个序列也是有序的。
} 
 
int main() { 
    // 输入
    scanf("%d", &n); 
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]); 
     
    // 快速排序
    quick_sort(1, n); 
    
    // 输出
    for (int i = 1; i <= n; ++i) printf("%d ", a[i]);  
    return 0; 
} 
```









## 总结

- **快速排序是一种基于分治法的排序**。其基本思想在于固定一个分界线，将整个序列按照小于分界线和大于分界线划分，然后再分别对划分好的子段进行排序。

- **快速排序的时间复杂度在理想情况下是O(n \log n)\*O\*(\*n\*log\*n\*)**，但如果选取分界线每次都是子段中的最大值或最小值的话，时间复杂度可能会**退化到O(n^2)\*O\*(\*n\*2)**。在内存使用上，因为整个移动过程都在原数组中进行的，所以属于原地排序。

- **sort函数是C++标准模板库（STL）中一种对快速排序的优化实现**，可以通过传入头指针、尾指针和比较函数来对数组中的对象进行排序。

- 快速排序示例：

  将数组{2, 3, 1, 5, 4}从小到大排列。

- 不使用sort函数

  将「整体框架」和「移动元素」进行合并，我们得到快速排序完整代码：

```c++
// 该代码参考 https://www.geeksforgeeks.org/quick-sort/
#include <bits/stdc++.h>
#define N 100010 
using namespace std; 
int n; 
int a[N]; 
 
void quick_sort(int l, int r) { 
    // 设置最右边的数为分界线
    int pivot = a[r];
    
    // 元素移动
    int k = l - 1;
    for (int j = l; j < r; ++j)
        if (a[j] < pivot) swap(a[j], a[++k]); 
    swap(a[r], a[++k]); 
    
    if (l < k - 1) quick_sort(l, k - 1); // 如果序列的分界线左边的子段长度>1，排序
    if (k + 1 < r) quick_sort(k + 1, r); // 如果序列的分界线右边的子段长度>1，排序
    // 上面的过程结束后，到这里左子段和右子段已经分别排好序。又因为确定分界线以后的移动操作
    // 保证了左子段中的元素都小于等于分界线，左子段中的元素都大于分界线。所以整个序列也是有序的。
} 
 
int main() { 
    // 输入
    scanf("%d", &n); 
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]); 
     
    // 快速排序
    quick_sort(1, n); 
    
    // 输出
    for (int i = 1; i <= n; ++i) printf("%d ", a[i]);  
    return 0; 
} 
```

- 使用sort函数

  > `sort`函数有三个参数，分别为**头指针**、**尾指针**和**比较函数**，其中如果排序对象定义了小于号的话，比较函数可省略。例如对于一个长为`n`的数组排序：

```c++
#include <bits/stdc++.h>
using namespace std;
int a[10] = {2, 3, 1, 5, 4};
int n = 5;
int main() {
    sort(a, a + n);  //sort函数的两个参数，头指针和尾指针
    for (int i = 0; i < n; ++i) cout << a[i] << ' ';
    cout << endl;
```







## 练习

### 统计数字_快速排序

某次科研调查时得到了n个自然数，每个数均不超过1500000000（1.5*10^91.5∗109）。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。

输入描述：

每组输入数据包含n+1行；

第一行是整数n，表示自然数的个数；

第2~n+1行，每行一个自然数。

数据规模：

40%的数据满足：1<=n<=1000；

80%的数据满足：1<=n<=50000；

100%的数据满足：1<=n<=200000，每个数均不超过1500000000（1.5*10^91.5∗109）。

输出描述：

每组输出包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。

示例 1：

输入：

```
8
2
4
2
4
5
100
2
100
```

输出：

```
2 3
4 2
5 1
100 2
```



实现

```cpp
#include <bits/stdc++.h>
using namespace std;
  
int a[300000];                    // 防止越界
int main(){
    int n, s = 1;
    cin >> n;
    for(int i = 1;i <= n;i++){
        cin >> a[i];
    }
    
    // TODO 请补全代码完成题目
    sort(a + 1,a + n + 1);        // 使用`sort`函数进行快速排序

    for(int i = 1; i <= n; i++){
        if(a[i] == a[i+1]){
            s++;                  // 计数
        }
        else{
            cout << a[i] << " " << s << endl;
            s = 1;
        }
    }
    return 0;
}

```





### 数列排序_快速排序

给定一个长度为`n (1 <= n <= 100000)`的序列，请你将他们从小到大排序后再输出。

输入描述：

第一行一个整数`n`，表示序列长度。

第二行`n`个整数。

输出描述：

一行，`n`个整数，排序后的数列。

示例 1：

输入：

```
5
3 5 2 1 4
```

输出：

```
1 2 3 4 5
```

实现

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[100010];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
    return 0;
}
```





