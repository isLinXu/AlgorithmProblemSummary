# 选择排序

---

## 引入

**排序算法**（Sorting Algorithm） 的作用在于对于给定的一个元素序列，输出满足某种顺序的该序列的一个排列。

**举例**

> 给定一个长度为`n`的整数序列`a`，输出该序列从小到大的排序。
>
> **输入**
>
> 1 3 2 5 4
>
> **输出**
>
> 1 2 3 4 5

当然，元素序列也可能是别的对象，例如字符串序列。此时，某种顺序指的就有可能是字典序。

**举例**

> 给定一个长度为`n`的字符串序列，输出该序列按[字典序](https://blog.csdn.net/HappyRocking/article/details/83619392?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-83619392.pc_agg_new_rank&utm_term=字典序规则&spm=1000.2123.3001.4430)大小从小到大的排序。
>
> **输入**
>
> abc bc aab cd
>
> **输出**
>
> aab abc bc cd



**排序算法**是一种非常基础的算法。其基础的地方在于：

1. 现实生活中，有很多需要排序的场景。

> 比如班级里的成绩排名，选校时候的学校排名，微博热搜榜的热度排名等.

1. 排序算法是很多算法的关键一步。

> 比如对于数据库中需要查找某个记录的场景，在排过序的记录中查找会有更高效的算法。

所以，学习**排序算法**，根据**不同的需求**设计更高效的**排序算法**是非常有必要的。



## 选择排序

**选择排序**（Selection Sort）是我们学习的第一个排序算法。这里，我们尝试按照选择排序的思路，自己将其设计出来。首先，我们来思考一个问题

> 想把一个完全无序的序列按照从小到大排序，排在**第一个的元素**应该是谁？

这个问题的答案很简单：就是整个序列中的**最小值**！

那么，假如我们把**最小的元素**选择出来，放在答案序列的**第一位**。那么，后面要解决的问题，就只需要将剩下的`n-1`个元素排序放在答案的`2~n`位置即可。

若想排序剩下的`n-1`个元素，我们也可以用同样的思路：排在剩下元素第一位的一定是剩下元素的最小值！所以我们再求出剩下`n-1`个元素的**最小值**，然后放在答案序列的**第二位**。

所以，按照同样的流程，我们最终就能得出`n`个元素的排序。

![img](https://staticcdn.boyuai.com/user-assets/5085/rHrnhdfjpX8bgPgiQfj5Ku/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg!jpg)





## 详细算法描述

首先，我们先以8个元素的排序为例，模拟一下整个算法过程。

1. 找出`1~8`元素的最小值，并且记录最小值的位置为`k`。

2. 将其与第1位元素交换。

3. 找出`2~8`元素的最小值，并且记录最小值位置`k`。

4. 将其与第2位元素交换。

5. 照此过程一直进行，直到所有元素按照从小到大的顺序排列。

   

现在，我们尝试总结一下上面的算法

1. 按照从`1`到`n`的顺序，找出答案序列中放在该位置的元素。
2. 在寻找第`i`位的元素时，求出第`i`位到第`n`位的最小值，并记录最小值的位置`k`。
3. 交换第`k`位的元素与第`i`位元素。





## 代码实现

### 数组最小值

首先，如何找到`n`个元素的最小值，并记录它的位置？

- 最开始，我们默认最小值出现在数组的第`1`位，所以，用于记录最小值位置的变量`min_pos`初始值为`1`。
- 然后，枚举数组中的每个元素，并且将当前记录的最小值和枚举到的第`i`个元素作比较，如果当前枚举到的元素更小，说明最小值不可能出现在原来的`min_pos`位置，而更有可能出现的位置`i`。所以，将`min_pos`更新为`i`。
- 当扫描完整个元素后，`min_pos`中的位置就是最小值出现的位置。

```c++
#include <bits/stdc++.h>
using namespace std;
int a[1010];
int n;

int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i]; 
    //注意：为保持认知一致，我们直接从数组第2个元素开始。数组第二个元素索引为1，不是从索引为0的元素开始哦。
    
    int min_pos = 1;    // 设置最小值位置的初始值为0，即a[1] = 0
    for (int i = 2; i <= n; ++i) {
        if (a[i] < a[min_pos])  // 比较当前枚举到的元素与当前记录位置的元素
            min_pos = i;        // 如果当前记录位置的元素更小，则更新最小值出现的位置
    }
    cout << "minimum value = " << a[min_pos] << endl;    // 输出最小值
    cout << "minimum value pos = " << min_pos << endl;   // 输出最小值的位置
    return 0;
}
```

请根据**数组最小值**的思路补全右侧的代码。

右侧代码部分语句被挖空了，请在右侧代码中补全。运行验证正确后提交才可以解锁下一步哦～





### 实现选择排序

所以，给定长度为`n`的序列，我们现在用之前描述的选择排序过程用C++语言实现出来，将序列从小到大排序。

- 最外层用`for`循环枚举当前应该归位的第`i`个元素；
- 内层用上一步方法的寻找最小值位置，找出第`i`位一直到第`n`位的最小值，并且将其与原来的第`i`位元素交换。

具体实现如下：

```C++
#include <bits/stdc++.h>
using namespace std;
int a[1010];
int n;

int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 选择排序过程
    for (int i = 1; i < n; ++i) {  // 枚举应该归位的第i个元素，这里因为前n-1位归为以后，
                                   // 第n位也会归位，所以我们只枚举到n-1。
        int min_pos = i;           // 将最小值位置设置为当前范围i~n的首位
        for (int j = i + 1; j <= n; ++j) { // 将第i个元素和剩下的元素相比较
            if (a[j] < a[min_pos]) {       // 如果当前元素小于之前维护的最小值
                min_pos = j;               // 更改最小值出现的位置
            }
        }
        swap(a[i], a[min_pos]);            // 将最小值与第i个位置交换
    }
    
    // 输出
    for (int i = 1; i <= n; ++i) 
        cout << a[i] << ' ';
    return 0;
}
```

这样，我们就实现了选择排序。

请根据**完整选择排序**的思路补全右侧的代码。

右侧代码部分语句被挖空了，请在右侧代码中补全。运行验证正确后提交才可以解锁下一步哦～



## 总结

- 选择排序的基本思路是：
  1. 按照`1~n`的顺序，将每个元素依次归位。
  2. 当归位第`i`个元素时，我们需要选择出第`i`个元素到第`n`个元素的最小值，并且与第`i`个位置的元素交换。此时，`1~i`的元素分别为第`1`小到第`i`小的元素。
  3. 当第`n`个元素归位完毕以后，整个序列的排序过程结束。



## 练习

练习2·代码题

明明的随机数_选择排序

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

注：请使用选择排序方法完成此题。

输入描述：

每组输入有2行，第1行为1个正整数，表示所生成的随机数的个数N，第2行有N个用空格隔开的正整数，为所产生的随机数。

输出描述：

每组输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

示例 1：

输入：

```
10
20 40 32 67 40 20 89 300 400 15
```

输出：

```
8
15 20 32 40 67 89 300 400
```





### 明明的随机数_选择排序

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

注：请使用选择排序方法完成此题。

输入描述：

每组输入有2行，第1行为1个正整数，表示所生成的随机数的个数N，第2行有N个用空格隔开的正整数，为所产生的随机数。

输出描述：

每组输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

示例 1：

输入：

```
10
20 40 32 67 40 20 89 300 400 15
```

输出：

```
8
15 20 32 40 67 89 300 400
```

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 110
using namespace std;
int a[N], n, cnt;

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) 
        scanf("%d", &a[i]);

    for (int i = 0; i < n; ++i) {
        int min_pos = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[min_pos]) // TODO 请补全右侧代码完成选择排序
                min_pos = j;
        }
        swap(a[i], a[min_pos]) ; // TODO 请补全右侧代码完成选择排序
    }
  
    cnt = 0;
    for (int i = 0; i < n; ++i) 
        if (i == 0 || a[i] != a[i - 1]) 
            a[cnt++] = a[i];
            
    printf("%d\n", cnt);
    for (int i = 0; i < cnt; ++i) 
      printf("%d ", a[i]); 
    return 0;
}

```





### 简单排序_选择排序

给定一个长度为`n (1 <= n <= 1000)`的序列，请你将他们从小到大排序后再输出。

输入描述：

第一行一个整数`n`，表示序列长度。

第二行`n`个整数。

输出描述：

一行，`n`个整数，排序后的数列。

示例 1：

输入：

```
5
3 5 2 1 4
```

输出：

```
1 2 3 4 5 
```





实现：

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[1010];

int main() {
    // 请补全代码，实现题目功能
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
    return 0;
}
```









