# 模拟算法

---

## 当我们谈论模拟的时候

在学习或工作中，你可能常常需要执行下面的一些实验流程：

> 1. 调用A代码，生成测试数据，并保存在指定目录下。
> 2. 调用B代码，以刚生成的测试数据作为输入，产生结果。
> 3. 调用C代码，对B代码产生的数据进行评估。

如果每次都手动进行这三个步骤，不但需要随时关注每个程序是否运行完毕，同时人的反应时间是**有限**的，所以操作起来不但费事，而且很**慢**。更何况对于多组实验的情况，如果每组都需要手动进行，将会带来**更多麻烦**。

这时，我们就会希望有个工具能够帮我们自动化的实现这些操作。

 

- **模拟**算法就是这种可以帮我们实现自动化的工具。所谓**模拟**，就是按照题目的要求或者情境的设定完整实现其描述过程的方法。

> - 其实，**模拟算法**对思维与算法设计的要求并不高，但是会考验编程的基本功是否扎实。

> - 通常，我们要设计的不是“**算法**“，而是 **“实现方法”**。

> - 这要求我们对**数组**、**字符串**等操作非常熟悉，才能找到**更优美的实现方法**。

 

例如:针对这个实验：

> 1. 调用A代码，生成测试数据，并保存在指定目录下。
> 2. 调用B代码，以刚生成的测试数据作为输入，产生结果。
> 3. 调用C代码，对B代码产生的数据进行评估。

可以写一个[bash脚本](https://zhuanlan.zhihu.com/p/39748065)（这里只是举例说明**模拟**的作用，无需掌握bash脚本）来实现这个流程：

```bash
#!/bin/bash
for i in {1..10}
do
    ./A > data/test_in_${i}.txt
    ./B < data/test_in_${i}.txt > data/test_out_${i}.txt 2> log/debug_${i}.txt
    ./C < data/test_out_${i}.txt > output/result_${i}.txt
done
```

这样一来，我们只需要调用这个脚本，就可以自动完成10次实验流程。

在这里，我们写了一个程序，将刚才需要手动执行的实验流程“**模拟**”了一遍，这就是**模拟算法**。

> 注：这里无需你掌握bash脚本的编写方法，只要理解这个程序“**模拟**”了一遍实验流程即可。当然，也很推荐你学习一下[bash脚本](https://zhuanlan.zhihu.com/p/39748065)咯～



```cpp
#include <bits/stdc++.h>
using namespace std;
double F = 64.0;

int main() {
    double C;
    cout << "F = " << F << endl;
    // TODO 请补全代码
    C = (F - 32) / 1.8; // 以华氏度为输入计算摄氏度
    cout << "C = " << C << endl;
}
```





## 常见基础模型1 —— 简单数学计算和统计

- 有一些**模拟**要解决的问题，其实就是单个或者很少个数学过程的拼接。

Tips: 将若干个固定的过程通过程序拼接在一起，就省去了每次按计算器的麻烦。

**举例**:  摄氏温度华氏温度转换器

> 我们都知道，摄氏温度转换成华氏温度的公式是F = C * 1.8 + 32*F*=*C*∗1.8+32。所以，我们可以以摄氏度为输入，华氏温度作为输出，写一个简单的**转换器**。

代码实现过程很简单，如下所示。

摄氏温度华氏温度转换器程序段：

```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
    double C, F;
    cout << "C = ";
    cin >> C;
    F = C * 1.8 + 32;
    cout << "F = " << F << endl;
}
```

**问题**：

华氏温度摄氏温度转换器

> 所以，同样地，我们也可以以**华氏度**作为输入，**摄氏度**作为输出，写一个**转换器**。

右侧我们给出了这个**转换器**的代码框架，但部分语句被挖空了，请在右侧代码中补全。

运行验证正确后提交才可以解锁下一步哦～





## 常见基础模型2 —— 简单数组模拟

- 其实，很多[**数据库**](https://baike.baidu.com/item/数据库/103728?fr=aladdin)的操作本质上也都是**模拟**。

Tips: 前文提到，有的时候需要一些**数据结构**维护数据库的操作，这是因为这些**数据结构**的运用可以使操作的效率更高。

**举例**: 考试记录

让我们考虑一个最简单的模型：

> 假设某考试机构要记录n*n*条考试成绩，达到90分算通过考试。初级考试分数记录在score数组中。
>
> 该考试可以反复参加，只记录最高成绩。
>
> 现在总共有m*m*条新记录，分别表示第a_i*a**i*个人，新参加了一次考试，得分为f_i*f**i*。
>
> 那么,最终有多少人通过了考试？

我们可以用如下程序**模拟**这个过程：

```C++
#include <bits/stdc++.h>
#define N  10001 // 假设人数不会超过10000人
using namespace std;
int score[N] = {-1, 89, 90, 91, 78, 99, 90, 94, 95, 68, 100}; // 机构原本记录的10条考试记录。
                                                              // -1表示占位，学生数据从score[1]开始记录
int n = 10; // 机构共有10条考试记录
int m = 3;  // 3人重新参加了考试

int main() {

    for (int i = 1; i <= m; ++i) {
        int a, f;
        cin >> a >> f;               // 重新输入重新参加考试的3人的成绩
        score[a] = max(f, score[a]); // 只维护最高的一次
    }
    int ans = 0;
    for (int i = 1; i <= n; ++i)
        if (score[i] >= 90) ++ans;
    cout << "answer = " << ans << endl;
    return 0;
}
```

**运行右侧程序**，输入重新参加考试的3人的成绩：

> 2 89
>
> 4 90
>
> 7 99

运行结果

```
考试记录： 89 90 91 90 99 90 99 95 68 100 
answer = 8
```







## 模拟练习 —— ISBN 号码

**ISBN 号码**是一道经典的**模拟**题目，现在尝试着通过阅读题目，根据注释补全全部代码吧！

**题目描述**

每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如 `x-xxx-xxxxx-x` ，其中符号-就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4` 就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符`-`之后的三位数字代表出版社，例如670670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

 

识别码的计算方法如下：

首位数字乘以`1`，加上，次位数字乘以`2`，……，以此类推，最后用所得的结果对11取模，所得的余数即为识别码。如果余数为`10`，则识别码为大写字母`X`。

例如ISBN号码`0-670-82162-4`中的识别码`4`是这样得到的：对`067082162`这`9`个数字，从左至右，分别乘以`1,2,...,9`再求和，即`0×1+6×2+……+2×9 = 158`，然后取`158 mod 11`的结果`4`作为识别码。

你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出`Right`；如果错误，则输出你认为是正确的ISBN号码。 

> **输入格式**
>
> 一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。
>
> **输出格式**
>
> 一行，假如输入的ISBN号码的识别码正确，那么输出`Right`，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符`-`）。

 

```
输入样例1 

0-670-82162-4

输出样例1

Right

输入样例2

0-670-82162-0

输出样例2

0-670-82162-4

说明/提示: 题目来源：NOIP2008普及组
```

> **特别提示**：
>
> - 在对字符数组中的数字字符做乘法运算时不要忘记减’0’转换为阿拉伯数字再进行计算;
> - '-'字符跳过乘法操作;
> - 在判断标识码是否正确以及更改标识码的时候都不要忘记sum%11==10的情况标识码为’X’;

```cpp
//参考答案
#include <bits/stdc++.h> 
using namespace std;  
char str[20];  
  
int main() {  
    scanf("%s", str);  
    int idx = 0;  
    int tmp = 0; // 识别码   
    int len = strlen(str);  
    for (int i = 0; i < len - 1; ++i) {   
        if ('0' <= str[i] && str[i] <= '9') {  
            ++idx;
            // 在对字符数组中的数字字符做乘法运算时不要忘记减’0’转换为阿拉伯数字再进行计算;
            tmp = (tmp + (str[i] - '0') * idx) % 11;  
        }  
    }

    char c = tmp == 10 ? 'X' : tmp + '0';  // 计算识别码  
    if (str[len - 1] == c) 
        printf("Right");  
    else {  
        str[len - 1] = c;  
        printf("%s", str);  
    }  
    return 0;  
}
```



## 拓展——复杂模拟举例

很多在计算机上实现的小游戏，本质上都是模拟。

**举例**：扫雷游戏

如果要自己实现一个扫雷游戏，就需要按照其规则进行模拟。其中，假设需要支持以下的操作：

> 1. 对于用户给定的棋盘大小和雷的个数，随机雷的位置并初始化棋盘。
> 2. 对于用户给的坐标，判断是否为地雷，如果是，结束游戏，如果不是，则展开该位置。如果该位置数字为0，则在周围继续展开直到碰到大于0的数字为止。
> 3. 输出棋盘局面，如果该轮游戏没有结束，则重复2~3过程。

拿其中的两个基础模块举例子：打印整个棋盘和展开一部分棋盘。

> - 在整个棋盘中，我们用`num[x][y]`表示(x, y)(*x*,*y*)的状态;
> - 如果`num[x][y] >= 0`，则该位置是一个数字；
> - 如果`num[x][y] < 0`，则该位置是一个地雷；
> - 另外，用`clear[x][y]`表示该位置有没有展开。

- 打印棋盘

```C++
int n, m;
int num[N][N];
bool clear[N][N];

void printMap() {
    for (int x = 1; x <= n; ++x) {
        for (int y = 1; y <= n; ++y) {
            if (!clear[x][y]) cout << '#';			// 没有展开
            else if (num[x][y] == -1) cout << '@';	// 地雷
            else if (num[x][y] == 0) cout << '.';	// 数字 == 0，周围没有地雷
            else cout << num[x][y];					// 数字 > 0
        }
        cout << endl;
    }
}
```

- 展开棋盘

```C++
int tot;	// 在main函数中初始化为 棋盘总格子数 - 地雷数
const int dx[] = {1, 0, -1, 0, 1, 1, -1, -1}; // 8个相邻方向的x坐标变化
const int dy[] = {0, 1, 0, -1, 1, -1, 1, -1}; // 8个相邻方向的y坐标变化

void dfs(int x, int y) {
    if (clear[x][y] || num[x][y] == -1) // 如果已经展开或者是地雷，就不展开
    clear[x][y] = false;
    --tot;	// 总未展开的非地雷格子个数减1
    if (num[x][y] > 0) return; // 如果周围有地雷，就不继续展开
    for (int i = 0; i < 8; ++i) {
        int xx = x + dx[i];
        int yy = y + dy[i];
        // 向第i个方向继续展开
        if (1 <= xx && xx <= n && 1 <= yy && yy <= n) dfs(xx, yy);	
    }
}
```

可见在计算机上实现一个小游戏的平台，游戏的推进和状态的判定都是在对游戏规则的模拟。

**举例**:德州扑克

德州扑克中，最重要的操作就是给定两副手牌，要求按照德州扑克的规则比较它们的大小。

众所周知，德州扑克牌型从大到小分别分为”同花大顺“”同花顺“”四条“”葫芦“同花“”顺子“”三条“”两对”“一对”和“散排”。

那么如何写一段程序将手牌正确归类就是一个很有趣的模拟练习。



总结

- **模拟算法**就是按照题目的要求或者情境的设定完整实现其描述过程的方法。

Tips：它虽然在思维上没有太高的要求，但是对于一些复杂的过程，选择实现的方法从而形成一段**代码简洁而运行高效**的算法，很考验程序员的基本功和经验积累。

- **ISBN 号码问题**：

完整代码：

```c++

#include <bits/stdc++.h> 
using namespace std;  
char str[20];  
  
int main() {  
    scanf("%s", str);  
    int idx = 0;  
    int tmp = 0; // 识别码   
    int len = strlen(str);  
    for (int i = 0; i < len - 1; ++i)   
        if ('0' <= str[i] && str[i] <= '9') {  
            ++idx;
            // 在对字符数组中的数字字符做乘法运算时不要忘记减’0’转换为阿拉伯数字再进行计算;
            tmp = (tmp + (str[i] - '0') * idx) % 11;  
        }  
 
    char c = tmp == 10 ? 'X' : tmp + '0';  // 计算识别码  
    if (str[len - 1] == c) 
        printf("Right");  
    else {  
        str[len - 1] = c;  
        printf("%s", str);  
    }  
    return 0;  
}
```





```cpp
总结
模拟算法就是按照题目的要求或者情境的设定完整实现其描述过程的方法。
Tips：它虽然在思维上没有太高的要求，但是对于一些复杂的过程，选择实现的方法从而形成一段代码简洁而运行高效的算法，很考验程序员的基本功和经验积累。

ISBN 号码问题：
完整代码：

#include <bits/stdc++.h> 
using namespace std;  
char str[20];  
  
int main() {  
    scanf("%s", str);  
    int idx = 0;  
    int tmp = 0; // 识别码   
    int len = strlen(str);  
    for (int i = 0; i < len - 1; ++i)   
        if ('0' <= str[i] && str[i] <= '9') {  
            ++idx;
            // 在对字符数组中的数字字符做乘法运算时不要忘记减’0’转换为阿拉伯数字再进行计算;
            tmp = (tmp + (str[i] - '0') * idx) % 11;  
        }  
 
    char c = tmp == 10 ? 'X' : tmp + '0';  // 计算识别码  
    if (str[len - 1] == c) 
        printf("Right");  
    else {  
        str[len - 1] = c;  
        printf("%s", str);  
    }  
    return 0;  
}
```





## 练习4·代码题

### 扫雷游戏

扫雷是Windows自带的游戏。游戏的目标是尽快找到雷区中的所有地雷，而不许踩到地雷。如果方块上的是地雷，将输掉游戏。

如果方块上出现数字，则表示在其周围的八个方块中共有多少颗地雷。

你的任务是在已知地雷出现位置的情况下，得到各个方块中的数据。

输入描述：

输入有多组数据，每组数据的第一行有两个数字，`m, n (0 < m, n< 100)`表示游戏中雷区的范围为`m×n`。接下来`m`行每行有`n`个字符。`*`表示有地雷，`.`表示无地雷。最后一组数据`m = 0, n = 0`表示输入结束，不需要处理。



输出描述：

对于每组输入数据，输出结果，各方块数字间不留空格。地雷位置用`*`表示。

每组结果之后有一个空行。

示例 1：

输入：

```
2 3 
***
...
4 4
*...
....
.*..
....
0 0
```

输出：

```
***
232

*100
2210
1*10
1110
```



实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

char s[110];
int a[110][110];
int mx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int my[8] = {-1, 0, 1, -1, 1, -1, 0, 1};

int calc(int i, int j) {
    int ans = 0;
    for (int k = 0; k < 8; k++)
        if (a[i + mx[k]][j + my[k]] == 1)
            ans++;
    return ans;
}

int main() {
    // 请补全代码，实现题目功能
    int n, m;
    while (1) {
        scanf("%d %d", &n, &m);
        if (n == 0 && m == 0)
            break;
        memset(a, 0, sizeof(a));
        for (int i = 1; i <= n; i++) {
            scanf("%s", s);
            for (int j = 0; j < m; j++)
                if (s[j] == '*') 
                    a[i][j + 1] = 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (a[i][j] == 1)
                    cout << "*";
                else 
                    cout << calc(i, j);
            }
            cout << endl;
        }
        cout << endl;
    }
    
    return 0;
}

```



### 

### 高精度乘法（高精*高精）

求两数的积。说明/提示：每个数字不超过 10^2000 ，需用高精度。

输入描述：

两行，两个整数。



输出描述：

一行一个整数表示乘积。



示例 1：

输入：

```
123456789
987654321
```

输出：

```
121932631112635269
```

实现

```cpp
#include <bits/stdc++.h>
#define N 11111
using namespace std;

int a_digits[N], b_digits[N];
int a_len, b_len;
int ans_digits[N], ans_len;
char str1[N], str2[N];
int main() {
    cin >> str1;
    // 获取高精度整数长度
    int a_len = strlen(str1);	
    for (int i = 0; i < a_len; ++i)
        // TODO 请补全下述代码
        a_digits[i] = str1[a_len - i - 1] - '0'; // 将字符转换成数字，倒着存进数位数组
    
    cin >> str2;
    // 获取高精度整数长度
    int b_len = strlen(str2);	
    for (int i = 0; i < b_len; ++i)
        // TODO 请补全下述代码
        b_digits[i] = str2[b_len - i - 1] - '0' ; // 将字符转换成数字，倒着存进数位数组
    
    // 1. 数位操作
    ans_len = a_len + b_len;		// 初始化长度
    for (int i = 0; i < ans_len; ++i) 
        ans_digits[i] = 0; 
    // 因为是不断累加的形式，所以要将范围内的元素初始化为0。
    
    for (int i = 0; i < a_len; ++i) 
        for (int j = 0; j < b_len; ++j)
            // TODO 请补全下述代码
            ans_digits[i + j] += a_digits[i] * b_digits[j] ; // 乘法计算
    // ans的每一位更新都要使用累加的形式，这是因为对于ans的第k位，满足i + j == k的(i, j)很多，所以可能答案的第k位可能先后被更新很多次。
    
    // 2. 统一进位
    int k = 0;
    for (int i = 0; i < ans_len; ++i) {
        // TODO 请补全下述代码
        ans_digits[i] += k;
        k = ans_digits[i] / 10;
        ans_digits[i] %= 10;
    }
    
    // 3. 维护长度
    while (ans_len > 1 && ans_digits[ans_len - 1] == 0) 
        --ans_len;
    
    // 4. 输出
    for (int i = ans_len - 1; i >= 0; --i) 
        cout << ans_digits[i];
    cout << endl;
    return 0;
}

```



### 高精度加法

高精度加法，相当于a+b problem，不用考虑负数.

输入描述：

分两行输入。a, b ≤ 10^10000

输出描述：

输出只有一行，代表a+b的值

示例 1：

输入：

```
1001 9099
```

输出：

```
10100
```

实现

```cpp
#include <bits/stdc++.h>
#define N 11111
using namespace std;

int a_digits[N], b_digits[N];
int a_len, b_len;
int ans_digits[N], ans_len;
char str1[N], str2[N];
int main() {
    cin >> str1;
    // 获取高精度整数长度
    int a_len = strlen(str1);	
    for (int i = 0; i < a_len; ++i)
        // TODO 请补全下述代码
        a_digits[i] = str1[a_len - i - 1] - '0';  // 将字符转换成数字，倒着存进数位数组
    
    cin >> str2;
    // 获取高精度整数长度
    int b_len = strlen(str2);	
    for (int i = 0; i < b_len; ++i)
        // TODO 请补全下述代码
        b_digits[i] = str2[b_len - i - 1] - '0' ; // 将字符转换成数字，倒着存进数位数组
    
    ans_len = max(a_len, b_len); 	// 初始长度
    int k = 0;						// 记录进位的变量
    for (int i = 0; i < ans_len; ++i) {
        // 假设a_len > b_len，这里需要保证b[b_len]到b[a_len - 1]的位置都是0，否则可能会出错。
        // TODO 请补全下述代码
        ans_digits[i] = a_digits[i] + b_digits[i] + k ; // 相加计算
        k = ans_digits[i] / 10 ;     // 更新进位
        ans_digits[i] %= 10;
    }
    
    
    if (k) 
        // TODO 请补全下述代码
        ans_digits[ans_len++] = k;	// 最高位进位
    
    // 3. 输出
    // 按照打印顺序输出，从高位到低位。
    
    for (int i = ans_len - 1; i >= 0; --i) 
        cout << ans_digits[i];
    cout << endl;
    
    return 0;
}

```



### 高精度减法

输入两个大整数`a``b`，计算`a - b`的结果，其中数据保证`0 < b < a < 10^500`。

输入描述：

一行，两个大整数`a``b`，中间用空格隔开。

输出描述：

一行一个整数，表示`a-b`的结果。

示例 1：

输入：

```
10000 9990
```

输出：

```
10
```



实现

```cpp
#include <bits/stdc++.h>
using namespace std; 

int a[1000010], b[1000010], c[1000010], lena, lenb, lenc, i;
char n[100010], n1[100010], n2[100010];

int main() {
    // 请补全代码，实现题目功能
    scanf("%s", n1);
    scanf("%s", n2);
    if (strlen(n1) < strlen(n2) || (strlen(n1) == strlen(n2) && strcmp(n1, n2) < 0)) {
        strcpy(n, n1);
        strcpy(n1, n2);
        strcpy(n2, n);
        cout << "-";
    }
    lena = strlen(n1); lenb = strlen(n2);
    for(i = 0; i <= lena - 1; i++) a[lena - i] = int(n1[i] - '0');
    for(i = 0; i <= lenb - 1; i++) b[lenb - i] = int(n2[i] - '0');
    i = 1;
    while (i <= lena || i <= lenb) {
        if (a[i] < b[i]) {
            a[i] += 10;
            a[i+1]--;
        }
        c[i] = a[i] - b[i];
        i++;
    }
    lenc = i;
    while ((c[lenc] == 0) && (lenc > 1)) lenc--;
    for (i = lenc; i >= 1; i--) cout << c[i];
    cout << endl;
    return 0;
}

```



### ISDN号码

每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以1加上次位数字乘以2...以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，...，9，再求和，即0×1+6×2+...+2×9=158，然后取158 mod 11的结果4作为识别码。

你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出你认为是正确的ISBN号码。

输入描述：

每组输入数据只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。

输出描述：

每组输出共一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。

示例 1：

输入：

```
0-670-82162-4
```

输出：

```
Right
```

实现
```cpp
#include <bits/stdc++.h>
using namespace std; 

char str[20];

int main() {
    // 请补全代码，实现题目功能
    scanf("%s", str);  
    int idx = 0;  
    int tmp = 0; // 识别码   
    int len = strlen(str);  
    for (int i = 0; i < len - 1; ++i)   
        if ('0' <= str[i] && str[i] <= '9') {  
            ++idx;
            // 在对字符数组中的数字字符做乘法运算时不要忘记减’0’转换为阿拉伯数字再进行计算;
            tmp = (tmp + (str[i] - '0') * idx) % 11;  
        }  

    char c = tmp == 10 ? 'X' : tmp + '0';  // 计算识别码  
    if (str[len - 1] == c) 
        printf("Right");  
    else {  
        str[len - 1] = c;  
        printf("%s", str);  
    }  
    return 0;
}

```







